# go语言的编译器和编译环境搭建

就像c语言需要`gcc`,同样作为静态语言,go语言也需要现有编译器才可以编译源码.

我们可以去[go语言的官网](https://golang.org/doc/install)下载安装,如果和我一样是mac用户,可以借助[Homeberry](http://blog.hszofficial.site/recommend/2016/06/28/mac%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7homebrew/)安装

```shell
brew install golang
```

装好后并不是直接可以用,go语言有这么几个比较重要的环境变量需要设置

+ `GOPATH` 用于标明GO语言的默认全局编译和安装工作目录,类似python中的`site-packages`,其中会有`src`,`pkg`和`bin`三个目录,分别是项目的源码,库文件和可执行文件.
+ `GOROOT` 用于标明Go语言的安装目录

其他的还有一些我们用到的时候再说,如果要查看当前安装环境下与go语言有关的全部环境变量,可以使用命令
`go env`查看.

同时为了方便起见,也应该向环境变量中的`PATH`中添加`$GOPATH/bin`,这样全局安装的go程序就可以直接执行了.

## 编译和解释

从python,js这类动态语言过来的同学可能有些不理解什么是编译器.在动态语言中有解释器用于解释执行源码,即将源码先翻译为二进制码,然后解释器将这些二进制码通过调用内部的对应虚拟机执行.像java虽然说自己是静态语言,但实质上也是这个流程,只是它是按模块读取二进制码不是逐行读取,并且不允许运行时修改而已.

而类似C语言,Go语言这类则是完全不一样的路数--编译器会先读取源码,做好类型检测,语法检测,然后将其直接编译为机器可以执行的机器码,然后通过链接的方式将不容模块链接合并成动态库,静态库或者可执行文件.

因此python执行总是`python xxxx.py`,js执行总是`node xxx.js`,java执行也总是`java xxxx.jar`,毕竟他们其实是使用解释器解释程序让他在虚拟机中执行;而C,go这类则是编译出个叫`hello`的程序后,直接使用`./hello`就可以执行了,因为编译好的程序是操作系统本身就可以执行的程序.

## helloworld

我们惯例的从一个helloworld开始这一系列.一个典型的go语言项目结构中包括以下几个部分:

1. `go.mod`文件,用于描述项目的依赖关系

    ```text
    module helloworld //描述项目名

    go 1.15 //描述项目最低支持的go语言版本
    ```

2. 入口文件,用于作为程序入口

    ```go
    package main

    import "fmt"

    func main() {
        fmt.Println("Hello, 世界 Golang!")
    }
    ```

### 编译可执行文件

go编译程序使用命令[`go build [-o output] [-i] [build flags] [入口文件]`](https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies)

我们的纯go程序编译出来是纯静态的,因此可以没有任何依赖的执行,但go支持使用`cgo`嵌入c语言,这就会引入依赖,控制是否使用`cgo`的环境变量为`CGO_ENABLED`,为`1`表示使用cgo,为`0`表示不适用.
如果我们不用cgo那最好确认好`CGO_ENABLED=0`

### 执行程序

和c语言一样,我们直接执行编译出来的可执行文件即可.

## 静态库

go语言早期只支持[静态库](https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E5%BA%93/8955694),我们的第二个例子就来构建一个静态库.这个静态库实现[牛顿法求平方根](https://tour.go-zh.org/flowcontrol/8).

go在早期使用`GOPATH`来控制包依赖,现在`GOPATH`已经基本不再被推荐使用,官方现在推的是`go mod`模式,也就是我们上面的模式.但如果希望本地构造的静态库可以被简单的放入`GOPATH`中依然只能使用`GOPATH`模式.这种模式说白了就是把项目全部放在环境变量`GOPATH`指定的根目录下.比如我们要构造一个静态链接库`mymath`,就在`$GOPATH/src/mymath`目录下写源码即可.当然`go mod`模式也可以编译编译静态库,只是默认存放位置的位置不知道在哪里,因此更常见的用法是使用`-o`指定存放位置

+ sqrt.go

```go
package mymath

func Sqrt(x float64) float64 {
    z:=1.0
    for i:=0;i<10;i++ {
        z -= (z*z-x)/(2*z)
    }
    return z
}
```

go中判断一个函数或结构体是否模块外可见使用的是首字母来区分,如果是大写则为可见,否则不可见.像上面的代码我们的`Sqrt`函数就是可见的.

我们将这个文件命名为`mymath.go`,放在`$GOPATH/src/my/mymath`目录下.

### 编译静态库

编译静态库一样是两种方式:

1. `go path`模式
   1. 在`$GOPATH`下使用`go install my/mymath`命令
   2. 在`$GOPATH/src/my/mymath`目录下使用`go install`命令

2. `go mod`模式
   1. 在有`go.mod`的文件夹下使用`go build`命令

### 调用静态库

如果静态库在`GOPATH`模式下安装,则调用静态库也很简单,只需要使用`import`语句即可

```go
package main

import (
    "fmt"
    mymath "my/mymath"
)

func main() {
    fmt.Println(mymath.Sqrt(2))
}
```

调用可用的静态库,其搜索路劲按顺序依次为

1. 本地`vendor`文件夹(这个在下一节`依赖控制`部分讲)
2. 环境变量`GOPATH`下
3. 环境变量`GOROOT`下

如果我们给库定义了别名,那么我们就可以在后面的代码中使用这个别名代表这个库,这就有点像python中的`import xxx as yyy`

### go mod模式下的"本地静态库"

如果我们希望本地构造静态库,又希望不用`GOPATH`而是使用`go mod`,那目前看是不行的,但我们还是可以通过迂回的方式使用`本地静态库`.
就是在要使用本地静态库的项目的`go.mod`中使用如下设置将依赖的本地库指定给调用方即可

```text
require mymath v0.0.0

replace mymath => ../mymath

```

这种方式本质上并没有使用静态库,而是使用了其源码,golang的最大优势就是编译快,利用这一优势实际上静态库并不是很有必要.这也是为啥golang模块的分发方式是源码分发.

## 动态库 (golang 1.8+)

在go 1.8版本加入了对[动态库](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/100352)的支持,使用标准库[plugin](https://golang.org/pkg/plugin/)来实现.目前它还只支持linux和mac.是的,动态库在go语境下叫做插件,这主要是为了和c语言的动态库做区分,事实上go对C语言相当亲和,go代码可以直接编译为c语言的动态库.这个后面再说.

### 例子

我们先从一个例子开始直观的了解下动态库.

+ 编译动态库

我们还是以这个牛顿法求开根号的项目为例子.这回我们不能直接用使用上面的代码,必须将package改为main

```go
package main

func Sqrt(x float64) float64 {
    z:=1.0
    for i:=0;i<10;i++ {
        z -= (z*z-x)/(2*z)
    }
    return z
}
```

这个文件我们放在`$GOPATH/src/calculsqrt_plugin`文件夹下,使用如下命令编译

```bash
go build -buildmode=plugin -o sqrt.plugin
```

这样就可以编译一个插件了,执行上面的命令后我们可以再这个文件夹下获得动态库文件`sqrt.plugin`

+ 使用动态库

在相同文件夹下我们写一个入口模块`main.go`

```go
package main

import (
    "fmt"
    "plugin"
)

func main() {
    // 加载动态库
    module, err := plugin.Open("./sqrt.so")
    if err != nil {
        fmt.Println("plugin load error")
    } else {
        //在动态库中查找方法
        Sqrt, err := module.Lookup("Sqrt")
        if err != nil {
            fmt.Println("no Sqrt in plugin")
        } else {
            //为函数赋予类型后再调用
            fmt.Println(Sqrt.(func(float64) float64)(2))
        }
    }
}
```

可以看到动态库的使用和python中使用ctype调用c语言的动态库很像,需要先加载,再找到对应的函数,然后还要为这个函数赋予一个类型,最后才能调用.

之后就像之前的程序编译一样直接使用`go install`安装就好,可以看到程序正常编译和安装了,执行`calculsqrt_plugin`也可以获得正确答案.

### 动态库的使用模式

`plugin.Open( string ) (*plugin.Plugin, error)`函数返回的是一个插件模块,它和导入模块作用是差不多的,都会触发模块初始化.但`*plugin.Plugin`这个对象并不能知道模块中有什么,因此需要我们在主函数中通过`module.Lookup("Sqrt")`这样的方式搜索变量,然后将变量声明为符合要求的类型然后使用.由于`module.Lookup`只能搜索变量(函数在go中也是变量),因此有可以分化出两种使用模式:

+ 使用插件封装函数:

    1. 插件中只有函数,
    2. 主函数清楚的知道插件中的函数名和对应的签名
    3. 主函数将插件中的函数提取出来后当做本地函数使用

    我们上的例子就是这种思路

+ 使用插件封装对象:
    1. 外部模块(主模块)中定义好模块中创建好的对象的接口
    2. 插件中定义结构体并使其满足接口,并初始化好一个全局变量保存一个实例
    3. 主函数中查找固定的变量名,并为其指定类型为规定好的接口.

### 动态库的使用场景

动态库真的不常用,但也不是没有使用场景的,它的主要使用场景如下:

1. 动态扩展功能范围,由于动态库是运行时导入模块的唯一方法,通过监听文件系统我们甚至可以动态的增加程序的能力范围.这一般用在服务端技术上
2. 动态更新软件,另一种极端的用法是通过推送推送插件,从而实现版本更新,这一般用在客户端技术上.

### 动态库的使用限制

动态库看起来简直太美好了,但实际使用的非常少,为什么呢?主要是因为使用限制极多而且极为致命:

1. 插件和主程序必须保证使用go语言编译器版本完全一致
2. 插件中使用的库如果在主程序中也有用到得化必须保证版本一致
3. 如果采用mod=vendor构建,那么主程序和plugin必须基于同一个vendor目录构建
4. 只支持Linux, FreeBSD和macOS.且macOS似乎支持也有问题
5. 使用plugin的主程序仅能使用动态链接,也就是说我们编译出来的主程序不再是一个完整的可以随便在同平台间移植的程序了.
6. 加载后的动态库无法卸载
7. plugin使用`pluginpath`作为唯一标识,这也就是默认情况下同一文件夹路径下编译出来的插件即便内容完全不一样也会被当做是同一个插件.
    我们可以通过编译的时候加上参数`--ldflags="-pluginpath=<你希望的唯一标识>"`来指定这个值,但目前的版本中会出现无法连接的问题([#39142](https://github.com/golang/go/issues/39142)).这无疑增加了插件自身版本管理的难度.

因此我们可以看到极少有项目使用这一特性.毕竟它带来的麻烦看起来比便利多得多.当然也有勇者,感谢TiDB项目为我们结结实实踩了这一特性的坑,并贡献了[一篇质量极高的使用参考](https://github.com/pingcap/tidb/blob/master/docs/design/2018-12-10-plugin-framework.md).

目前看来如果希望使用插件功能,我们最好的选择似乎是使用[hashicorp/go-plugin](https://github.com/hashicorp/go-plugin).但本质上它只是grpc的封装.

### 克服动态库的先天缺陷

那是不是动态库就没有价值了呢?当然不是.用也不是不能用,只是要权衡利弊以及使用与之相配套的代码组织还有发布形式.具体措施有:

1. 使用docker分发程序,以克服其无法在window上部署以及不再静态的缺陷
2. 完全使用`go mod`方式管理依赖,做到依赖版本完全一致
3. 使用`vs code`的`Remote-Containers`插件,通过统一的开发镜像在容器中进行开发以控制go编译器的版本
4. 使用ci-cd工具(比如 gitlab-runner,github-action,jenkins),在统一的镜像中编译构造程序的镜像
5. 插件根据版本放不同文件夹中管理
6. 监控插件文件夹,
7. 只用在模块化扩展功能范围上,别想着动态加载.

## go语言的分发模式点评

go语言虽然编译为静态库和插件库,但实际上一般都不用这些方法分发库,而是用更简单粗暴的方法--源码分发.下面我们来看下这三种方式的对比:

| 分发方式 | 跨平台                               | 安装时长 | 调用方便程度 |
| -------- | ------------------------------------ | -------- | ------------ |
| 静态库   | 必须先编译后分发                     | 短       | 很方便       |
| 插件库   | 必须现编译后分发,且不支持windows平台 | 短       | 不太方便     |
| 源码库   | 直接分发                             | 比较短   | 很方便       |

我们可以看出三种方法的胜负手在于安装时长,golang由于编译极快,因此依赖源码下载到本地后现编译也不会比直接使用二进制库慢多少,而其它方面源码分发也是最方便的,因此golang的主流分发方式就是源码分发.

而像热插拔这样的特性在极短的编译时间面前意义不大,完全可以依靠部署平台(docker swarm/k8s等)的热更新实现

## 交叉编译

go的另一大卖点是交叉编译,也就说我在mac上可以直接编译windows可以执行的程序.目前这一功能在各种语言中都属于相当先进的特性.

不过注意交叉编译是有限制的,如果用到CGO则不能直接交叉编译.而是需要使用环境变量`CC`和`CXX`指定c/c++的对应交叉编译工具链后才能进行

而使用的方式也是相当简单只要在编译时指定特定环境变量即可:

+ GOOS：目标操作系统
+ GOARCH：目标操作系统的架构

我们可以使用命令`go tool dist list`查看支持交叉编译的平台,

下面是目前支持的几个主流的交叉编译组合:

| OS        | ARCH                | OS version                   |
| --------- | ------------------- | ---------------------------- |
| `linux`   | `386 / amd64 / arm` | `>= Linux 2.6`               |
| `darwin`  | `386 / amd64 / arm` | `OS X (Snow Leopard + Lion)` |
| `freebsd` | `386 / amd64`       | `>= FreeBSD 7`               |
| `windows` | `386 / amd64`       | `>= Windows 2000`            |

无论是`go build`还是`go install`都可以通过指定这两个环境变量编译为对应平台的程序.它会在对应的文件夹下生成一个平台名+cpu命令集名的文件夹,用于存放跨平台的库或者程序,这其实在编译静态库的部分我们已经见识过了.

我们以上面的`calculsqrt`为例,在项目根目录执行命令`GOOS=windows GOARCH=amd64 go build`就可以在项目根目录获得windows上可执行的exe文件了.

## 减小可执行文件体积

go的编译速度很快,算是它的一大卖点,但比较让人诟病的就是它编译出来的可执行文件比较大,虽说硬盘是计算机上最不值钱的东西,但毕竟还是有一些场景我们不得不考虑可执行文件的大小比如在arm单片机上做些服务.我们有两种途径减小文件大小

+ 编译时指定一些参数

    我们可以指定`-ldflags "-s -w"`来减小编译出来的可执行文件大小,代价就是失去一些功能和信息.`-s`的作用是去掉符号信息.`-w`的作用是去掉调试信息.因此这种方式减小文件大小比较适合在已经经过充分测试的发行版上使用.这种方式经过我测试压缩我们的`calculsqrt`项目,从原始的2.25m压缩到了1.61m

+ 使用[upx](https://github.com/upx/upx)

    丑话说前面,upx并不保证可以在各个平台上正常执行,因此这个方案并不稳.upx是一个压缩工具,可以直接压缩可执行文件并且多数情况下不会影响其执行(但执行开始时会有一个解压过程).我们可以去项目的[release栏目下](https://github.com/upx/upx/releases)下按自己的开发平台下载这个工具,并将其加入到PATH环境变量下.

    ```bash
    upx --best --lzma -o $output $target
    ```

    压缩原始可执行文件后的可执行文件大小为1.12m;压缩经过`-ldflags`缩减过的可执行文件后其大小为576k.无论如何upx都是一个值得一试的工具,它确实可以解决问题.

## 静态可执行程序

GO语言默认情况下编译出来的可执行程序都是静态的,因此它有很好的可移植性.但也并不是说无论怎样GO语言编译出来的都是静态可执行文件,因为这里面有个CGO.

我们可以大致将GO语言的编译分为3类:

1. 纯GO语言程序
2. 标准库中有CGO实现
3. 外部有CGO实现

但在讨论这3种情况之前我们先来看看为甚GO比较容易构造静态可执行程序

### Runtime

之所以GO可以有这样的特性,其主要原因是它有独立实现的runtime.

runtime是支撑程序运行的基础,一般是编程语言和操作系统沟通的媒介.我们最熟悉的应该就是`libc`(C运行时),它是目前的主流操作系统上最普遍的运行时,通常以**动态链接库**的形式(比如`/lib/x86_64-linux-gnu/libc.so.6`)随着操作系统一起发布.而动态链接库我们知道是没法编译链接到静态可执行程序的.

libc等c的runtime历史悠久,同时也是许多其他编程语言的依赖,而由于历史悠久也就带来了版本割裂的问题.许多编程语言的可移植性问题也多是`libc`引起的.

GO语言果断没有使用`libc`而是自己另起炉灶,因此只要是纯使用go的程序就不会用到`libc`,也就可以直接编译成静态可执行程序了,同时弊端也就是GO的程序中包含runtime所以会很大.

### 标准库中有CGO实现

实际上go标准库中也有可以使用cgo实现的包,比如`net`,`mime/multipart`,`crypto/tls`等,当我们设置`CGO_ENABLED==1`时,这些包就会使用依赖的外部动态链接库;

对于标准库有cgo的情况我们还是可以通过设置`CGO_ENABLED=0`来比较简单的构造纯静态的可执行文件的.其原理在于这些标准库的链接操作不需要使用外部链接器(`gcc`/`clang`这类).GO的编译器只要重新编译这些库的静态版本,然后将静态版本的标准库直接链接进可执行文件就可以构成纯静态的可执行文件.这种工作模式被称为`internal linking`

### 外部有CGO实现

如果外部有使用CGO,那么情况就不一样了,由于使用了外部库,我们就必须依赖外部的链接器(`gcc`/`clang`这类).这种工作模式被称作`exernal linking`.

如果使用的外部库是静态链接还好,我们可以通过编译时加入flag`-ldflags '-linkmode "external" -extldflags "static"'`来强行让外部链接器做静态链接.这样还是可以构造出静态可执行文件的.

但如果依赖的是动态链接库,那么自然就没办法构造为静态可执行文件了.
