# 类型

go从来不是什么oop语言,其中的类型系统更加接近C中的概念,因此和例如python这样比较现代化的编程语言差别还挺大.随着1.18版本添加了泛型支持,go的类型系统看起来越来越奇怪,不过其实梳理下还是挺简单的,这边大致讲下我的理解,当然肯定有不对的地方.

## `type`关键字的个人理解

`type`关键个人认为是造成go语言类型系统看着乱的根源,尤其是学过其他编程语言的人.

+ 像学过python这种面向对象语言中普遍定义类使用`class`,这是比较好理解的,而我们会比较容易将`class`的概念平行迁移到`type`上
+ 像学过C的可能会好点,但也很容易将它认为是`typedef`

其实go中的`type`和以上都不一样

`type`关键字字现在在如下几个场景下可以被使用:

+ `type 类型名 其他类型名或对应内置容器`,一般意义上认为是定义一个类型为另一个类型
+ `type 类型名 = 其他类型名或对应内置容器`,一般意义上认为是定义类型的别名
+ `type 类型名 struct[...]{ ... }`,一般来说认为是声明一个自定义类型
+ `type 类型名 func[...](...)(...)`,一般来说认为是为一个函数签名命名
+ `type 类型名 interface[...]{ 约束定义 }`,一般认为是定义约束

可以看出来无论哪种场景`类型名`都是必须的,后面跟的是一个描述,因此可以将`type`语法简化为`type 类型名 类型描述`

个人理解go中的`type`的确切含义是声明一个类型,注意不是给类型取名,而是重新声明一个新的类型,和它比较接近的概念其实是`var`.

我们来用类比的方式看下上面的几个用法来体会下:

type用法|var用法
---|---
`type 类型名 其他类型名`| `var x = y`
`type 类型名 = 其他类型`| `var x = &y`
`type 类型名 struct[...]{ ... }`|`var x = new(C)`
`type 类型名 func[...](...)(...)`|`var x = func(...)(...){...}`

另外两个虽然没有对应的参照,但仔细体会下应该还是可以大致理解我说的更类似`var`这句话的意思.

个人理解`type`的作用是声明类型,任何类型名后的内容含义都是对声明类型结构的描述.因此类型名代表的是一个类型,而类型的有如下几种:

+ 基础类型
+ 自定义类型
+ 基础类型和自定义类型对应的内置容器结构
+ 函数结构
+ 结构体结构
+ 约束结构(接口和泛型约束都是一种约束描述)

这也解释了如下两个问题:

1. 为什么`type 类型名 其他类型名`声明的类型不会继承原本类型的方法,因为新类型获得了旧类型的结构但go中方法是函数的语法糖并不包含在类型中.
2. 为什么`type 类型名 = 其他类型`如果旧类型不是同一个包中声明的,则声明的类型无法添加方法,因为新类型就是原本的类型本生,原本类型已经在别的包里定义好的方法,而go语法跨包扩展类型的方法

## 基础类型

一般来说go中的基本类型就如下几种:

+ 整型数: `int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64`

+ 浮点数: `float32 float64`

+ 复数: `complex64 complex128`

+ 布尔值: `bool`

+ 字符串: `string`

+ 字节: `byte`即`uint8`的别名

+ Unicode: `rune`即`int32`的别名

从1.18版本开始go中新增了一个近似类型符号`~`用于标识基础类型及其派生类型,而它后面只可以是基础类型.在实际使用中我们发现如下的定义也不会报错

```go
type Exp1 interface {
    ~complex64 | ~[]complex128 | ~struct{ X int } | ~func(x int) error
}
```

因此可以看出实际和这些上面的基本类型同等地位的还有3类:

+ 内置容器结构,也就是`[]int`或者`map[string]int`这样的东西,
+ 结构体,也就是`struct{ ... }`.注意结构体本身无法命名,`struct`段只是描述了一个自定义结构.必须使用`type`将结构保存到一个类型中.因此可以认为一个`struct`段也是基础类型
+ 函数签名,也就是`func(...)(...)`,函数签名也只是描述一个函数结构,因此`func`段也可以认为是基础类型,不过同样的需要注意这里的函数签名不能包含泛型.

他们虽然不是基本类型,但我们可以看到应该可以将他们都归为一类,那就姑且叫它基础类型

## 派生类型

派生类型则是使用`type 类型名 类型描述`声明的类型(除了`type 类型名 = 旧类型`以及定义约束这种2种情况外).我们可将其看做是基础类型的派生.`type`会在自己所在package下创建一个新的派生类型.
由于结构体定义无法命名(和C语言中不同),所以自定义类型都是派生类型.

那派生类型有哪些特性呢?--而只有派生类型可以被绑定方法.没错即便是使用函数签名派生的类型也可以绑定方法,只是只能使用`值接收者`方式定义函数,如下例:

```golang
type FN func() string

func (fn FN) Echo(x string) string {
    return x + " " + fn()
}

func main() {
    fmt.Println(FN(func() string { return "func ok" }).Echo("echo"))
}
```

这个例子可以被正常编译执行.

## 对于`interface`语法的微词

当前的泛型设计复用了`interface`这个关键词,但在我看来这不是一个风格连贯的好设计,因为`interface`现在只能用于定义约束,而约束明显和派生类型有很大区别:

+ 带方法的`接口约束`无法作为类型约束的成员
+ `约束`并不能绑定方法

因此个人认为应该修改定义约束的语法为:

```go
interface 约束名 [...]{
...
}
```

同时保留原有声明语法用于向后兼容,然后2.0版本后删除对旧语法的支持.

这样定义约束时不再引入`type`关键字从而避免理解混乱.
