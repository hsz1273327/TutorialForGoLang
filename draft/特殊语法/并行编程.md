# 并行编程

golang之所以会流行很大程度上也依赖于它的并行编程能力.可以毫不夸张的说,编译型语言中,golang的并行编程简单程度是独一档的,而即便算上解释型语言,golang也是属于好写的那类.你几乎可以只用标准库就很轻易的完成并行编程.至于优雅不优雅,老实说一点不优雅.

一门编程语言并行编程好不好写只用看默认情况下给了多少相应工具即可,我们大致可以把并行编程归结为两个套路

1. 同步锁机制,也就是一堆任务发出去,大家各凭本事争夺共享资源的使用权限
2. 消息机制,也就是一堆任务发出去大家排好队等拿到数据再执行

这两个套路并不冲突,反而互补性很好,因此一门编程语言要适合并行编程最好是具备可以支持上面两种套路的工具.

在我看来并行编程最好写的是既有queue又有异步语法的python和c#,然后是只有queue但没有完整异步语法的golang,然后是有异步语法却没queue的js,然后是其他.

## 手上的工具

golang针对并行编程的工具可以分为如下:

1. `goroutine`
2. 锁
3. `goroutine`管理工具
4. `channel`
5. `channel`管理工具

### `goroutine`

`goroutine`是golang中唯一的并行化手段,我们先跳出go语言,复习下一般并行化手段有哪些.

+ `进程(process)`:分配完整独立的地址空间,拥有自己独立的堆和栈,既不共享堆,亦不共享栈,进程的切换只发生在内核态,由操作系统调度.
+ `线程(thread)`:和其它本进程的线程共享地址空间,拥有自己独立的栈,共享堆,不共享栈,线程的切换一般也由操作系统调度(标准线程).
+ `协程(coroutine)`:和线程类似,共享堆,不共享栈,协程的切换一般由程序员在代码中显式控制,因此实际上协程寄生于线程.

`goroutine`很多时候被翻译为协程,但实际协程需要可以由程序员再代码中控制切换,而goroutine本质上是一套隐式的并行机制,背后是一个调度器,用于自动的将程序分派给cpu处理,针对cpu密集任务它就是线程,针对io密集任务它也只是出让cpu资源,我们完全无法主动切换,因此将其理解为"不会被io阻塞的线程"更加合适.

golang中进入`main`函数就会创建一个根`goroutine`,而在调用函数时前面加上`go`关键字就可以创建一个新的`goroutine`,

```go
go func (){
    fmt.Println("abcdefg")
}()
```

golang中与`goroutine`相关的环境变量是`GOMAXPROCS`,它用于控制构造`goroutine`时最大使用的系统线程数,基本也可以理解为使用的最大cpu核数,默认值为本机cpu核数.

### 锁

主要是标准库`sync`中,包括同步锁`sync.Mutex`,读写锁`sync.RWMutex`,读写锁可以有效的防止资源争抢,尤其是在对对象状态的改变上.比如最常见的用法就是在pub/sub结构中和map配合使用,这一结构在websocket,sse等需要推送广播的场景下非常常用.

### `goroutine`管理工具

类似python中的多线程,当我们发出多个`goroutine`后我们是没办法直接知道什么时候都执行完毕的,而每个`goroutine`在创建时会消耗大约4k的内存空间.因此也不是说`goroutine`可以没有限制的创建.这就需要有对其的管理机制.

golang中标准库`sync`中收录了如下几个管理工具:

#### `sync.WaitGroup`

用于标识执行完了的`goroutine`,从而实现等待所有`goroutine`走完的效果.一般我们会在创建`goroutine`之前先为它加1,`goroutine`执行完后配合`defer`关键字为其减1,这样就可以正常等待了.

> 例子

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    
    wg := sync.WaitGroup{}
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            fmt.Println("goroutine ", i)
        }(i)
    }
    wg.Wait()
}
```

#### `sync.Once`

`sync.Once`这个工具可以控制无论起多少个`goroutine`,`sync.Once`控制的部分代码只会执行一次.

> 例子

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    once := sync.Once{}
    wg := sync.WaitGroup{}
    onceBody := func() {
        fmt.Println("Only once")
    }
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            fmt.Println("goroutine ", i)
            once.Do(onceBody)
        }(i)
    }
    wg.Wait()
}
```

#### `sync.Cond`

`sync.Cond`常用于广播条件以触发让等待中的`goroutine`取消阻塞状态向下执行.这有点像赛跑,每个`goroutine`先在同一个起跑线上等待发令,而发令枪就是`sync.Cond`,枪声一响大家就一起跑了.

需要注意`sync.Cond`中包含一个锁,这个锁需要配合一个标志位使用

> 例子

```golang
package main

import (
    "fmt"
    "sync"
    "time"
)

func run(id int) {
    for i := 0; i < 5; i++ {
        fmt.Println("goroutine", id, " running... ", i)
        time.Sleep(100 * time.Nanosecond)
    }
}
func main() {
    c := sync.NewCond(&sync.Mutex{})
    done := false

    wg := sync.WaitGroup{}
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Println("goroutine preparing ", id)
            c.L.Lock()
            for !done {
                c.Wait()
            }
            c.L.Unlock()
            run(id)
        }(i)
    }
    time.Sleep(100 * time.Nanosecond)
    fmt.Println("ready go")
    c.L.Lock()
    done = true
    c.L.Unlock()
    c.Broadcast()
    wg.Wait()
}

```

#### `sync.Pool`

`sync.Pool`是一个线程安全的池结构的实现,它用于保存和复用临时对象,减少内存分配,降低GC压力,它需要初始化的时候为`New`字段定义一个内容物的初始化函数,然后`Get`方法取出,`Put`方法放回.

### channel

channel一般翻译为信道.是go语言内置的一种数据结构,我们可以大致认为它是一个线程安全的定长queue,它是线程安全的.其实现大致如下:

> channel的实现介绍

每个channel内部实现都有三个队列

1. 接收消息的协程队列,这个队列的结构是一个限定最大长度的链表,所有阻塞在channel的接收操作的协程都会被放在这个队列里.

2. 发送消息的协程队列,这个队列的结构也是一个限定最大长度的链表,所有阻塞在channel的发送操作的协程也都会被放在这个队列里.

3. 环形数据缓冲队列,这个环形数组的大小就是channel的容量.如果数组装满了就表示channel满了;如果数组里一个值也没有就表示channel是空的.对于一个非缓冲通道来说,它总是同时处于即满又空的状态

#### 创建和关闭

channel是定长的,而且是有方向的.按方向分,可以分为三种:

+ 只读,其定义方式为`<- chan T`
+ 只写,其定义方式为`chan <-T`
+ 读写,其定义方式为`chan T`

通常我们定义channel时都是定义的读写型的,但声明函数形参时则会有指顶方向的情况.

按长度则分为两种:

+ 非缓冲通道,容量为0,其定义方式为`make(chan T)`
+ 缓冲通道,容量不为0,其定义方式为`make(chan T, n)`

像slice一样,我们在声明函数形参时并不需要关心channel的长度.非缓冲通道可以理解为状态即为满又为空的缓冲通道,而缓冲通道中可以缓存数据

#### 查看长度和容量

我们可以像查看slice一样查看channel的长度(`len`)和容积(`cap`).

#### 读写

channel的写操作就是`ch <- value`而读操作就是`variable[,isopen] <- ch`,其中`isopen`可以大致认为是表示一个接收到的值是否是在此通道被关闭之前发送的.

我们同样可以使用`for range`循环来读取channel中的数据,具体就是

```golang
for v := range ch{
    ...
}
```

#### 关闭

无论是哪种类型的channel,我们都使用内置函数`close(ch)`关闭他们,但是要注意关闭channel是一件非常需要小心谨慎的事情.事实上channel即便不关闭也没问题,只要没有地方使用它了它也会被gc回收走.

#### channel的行为

channel的行为由其状态决定.

channel存在3种状态:

+ `nil`,未初始化的状态只进行了声明,或者手动赋值为`nil`
+ `active`正常的channel,可读或者可写
+ `closed`已关闭

channel的行为大致可以用如下的矩阵图表示

| 操作  /状态 | nil      | closed   | active           |
| ----------- | -------- | -------- | ---------------- |
| 关闭        | panic    | panic    | 成功关闭         |
| 发送数据    | 永久阻塞 | panic    | 阻塞或者成功发送 |
| 接收数据    | 永久阻塞 | 永不阻塞 | 阻塞或者成功接收 |

上面的总结基本已经覆盖全了,还有如下4种情况根据是否是缓冲通道行为上有一些细节需要补充:

+ `active`状态执行`接收数据`操作:

    1. 如果通道非空则可以成功接收(非阻塞)
    2. 如果通道空且有发送端,则是非阻塞操作,会等待获取下一次的值
    3. 如果通道空且没有发送端,则通道阻塞,等待有发送端后被唤醒

+ `active`状态执行`发送操作`:

    1. 有接收端时可以成功发送(非阻塞)
    2. 没有接收端且通道未满,则数据缓冲到通道中,是非阻塞操作
    3. 没有接收端,且通道满了,则发送端阻塞,等待有接收端后激活并放入数据

+ `active`状态执行`关闭操作`:
    1. 如果还有接收端,则接收端会收到channel中剩下的数据,最后收到一个channel类型的零值,继续获取则会一致收到channel类型的零值.(非阻塞)
    2. 如果还有发送端,则发送端会获得panic

+ `closed`状态执行`接收操作`: 接收端会先收到channel中剩下的数据,且`isopen`位置为`true`,当剩下的数据都收完了后会一直收到channel类型的零值,而`isopen`位置为`false`

这边有一个特例:**对于nil状态的channel在select的某个case中时,这个case会阻塞但不会造成死锁**

#### 如何确定channel需要设置多长的容量

通常情况下使用非缓冲通道就已经足够,但如果并发高我们可以适当增加缓冲区以提高并发能力.那么多长合适呢,这就需要对并发量做出预估,通常我们会考虑设置机器cpu核心的数量或者其一半作为队列长度,如果这不够,那可能想办法增减消费端效率或者降低生产端效率会更靠谱些.

### `channel`管理工具

golang中`channel`的管理工具有3个:

+ 一个是`select-case`语句,用于阻塞等待多个channel以进行流程管理
+ 一个是标准库`context`,用于设置截止日期,同步信号,传递请求相关值
+ 一个是标准库`os/signal`,用于定义和传导操作系统的信号量

其中后两个都依赖于第一个`select case`语句

#### `select-case`语句

`select-case`分支流程控制语法是专为`channel`设计的语法.语法和`switch-case`分支流程控制语法很相似,但也有不少不同点,主要是:

1. `select`关键字和`{`之间不允许存在任何表达式和语句
2. `fallthrough`语句不能被使用.
3. 每个case关键字后必须跟随一个通道接收数据操作或者一个通道发送数据操作.而通道接收数据操作可以做为源值出现在一条简单赋值语句中
4. 所有的非阻塞case操作中将有一个被随机选择执行而不是按照从上到下的顺序执行,然后执行此操作对应的case分支代码块.
5. 在所有的case操作均为阻塞的情况下如果`default`分支存在则`default`分支代码块将得到执行;否则当前协程将被推入所有阻塞操作中相关的通道的发送数据协程队列或者接收数据协程队列中并进入阻塞状态