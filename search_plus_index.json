{"./":{"url":"./","title":"Introduction","keywords":"","body":"Golang攻略 Golang至少在当前的1.x阶段是一门相当简陋的语言.它可以理解为是C语言的直接升级版: 取消了头文件,改用命名的大写首字母来标明接口,使用接口(函数或属性签名)来作为类型限制 加上了gc和runtime,防止滥用malloc造成的内存溢出,同时提供了运行时反射 加上了原生的的并发封装,开发者不用再关心什么线程协程进程的问题 加上了对匿名函数的支持,方便构造回调. 加快了编译时间 加上了原生的多平台交叉编译功能 取消了对指针的的直接操作防止被滥用 取消了宏,防止被滥用 取消了空指针,防止被滥用 加上了go get命令用于依赖下载和安装,在1.11版本之后进一步加入了module系统用于控制单独项目的依赖(cmake) 加上了Gofmt命令控制编码风格,防止像C代码一样多种风格并存 加上了go test命令,并提供了统一的测试方案 加上了go doc命令,并提供了统一的文档风格. 可以看到go语言主要就是针对C语言开发的痛点进行了一些改进,它并没有加入什么新的编程范式,也没有显式的加入现代编程语言的特性.什么fp,oop一个都没有,但它在防止特性被滥用和统一周边工具链上下了功夫,也为高并发编程降低了心智负担. 虽然看了上面它对C语言的改进这么多,但要知道C语言是一门古老简陋的语言,即便有了上面的改进\b,Go语言的槽点一点也不少 没有泛型,这个是最大的槽点,C语言中还可以用宏部分的解决这个问题,在Go中就无解了,你只能要么牺牲性能使用interface{}然后靠运行时反射实现,要么通过第三方的代码生成器在程序外解决,相当不方便,C语言的主战场是系统编程,嵌入式软件和高性能科学计算,这种往往确实不需要泛型编程.但作为一门现代通用语言这就很尴尬了. 没有异常系统,代码里大量的if err != nil非常丑陋 编译出来的软件太大,虽然编译速度快了,但大小却变得大多了,于是go语言基本告别嵌入式领域(基于arm的linux编程不算) 这4个槽点让我在go早期完全无法接受,不过go语言官博上已经预告了2.0版本会增加泛型和异常系统,这让我重新有了写起相关攻略的动力. Go的定位 Go语言早期定位是系统语言,即对标的竞品是C/C++,然而由于上面的槽点,以及对指针的使用限制过严,性能也只能说上限是C这个级别,正常的Go程序往往性能还干不过java,因此这个定位基本也就说说而已. 但很快的工程师们发现了它真正的用武之地: 网络编程(底心智负担就可以实现高并发) 网络中间件(本质上还是网络编程) 分布式系统(本质上还是网络编程) 云计算系统(本质上还是网络编程) 区块链(本质上还是网络编程) 于是go在网络编程一块异军突起,实质上在和java竞争. 现在go的开发人员似乎也已经不再提什么系统编程了,而是强调可扩展性,这点上确实没啥可黑的,所有工程师使用一样的工具链,加上语法层面上是在是过于简单,学习成本相当低,这会让所有人写出来的代码看起来都差不多,自然也就增强了可维护性,也更加利于扩展.这点上确实没有哪门语言可以和它媲美.但也正是这点让它显得不近人情,坐实了自己是\"搬砖工具\". 总结go的比较优势就在于: 与动态语言相比性能优异,省内存 与大多数语言相比部署简单 与C++,java等语言相比语法简单学习成本低 与C,C++相比编译更快 与大多数语言相比并发编程省心智负担 与大多数语言相比规范更加统一(强制性的)因此可以带来维护效率上的提升 记住没有银弹,go也只适合做它适合的工作而已. 本文需要的先验知识 linux命令行操作 本文针对人群和内容范围 老实说go语言并不适合完全不懂编程的人学,它本身是简单,语言内部集成的东西是少,但编程本身不是一件简单的事情,这就造成了需要有大量语言本身之外的知识来支撑起编程这件事.这点也是和c语言一样.如果你是一个编程新手,还是建议从python入手,因为go语言多少受到了python的影响.而我给的文章也都更偏向应用并不适合纯新手学习,新手最好是找些更加基础的教程. 当然其实如果是光看这篇教程,那其实也不需要太高的水平,本质上这篇攻略是上手向的,只是因为不用IDE而且全部在命令行中操作所以可能外行看起来\"比较高端\".只要突破了这个障碍,这篇攻略应该只是一篇毫无难度的介绍文章而已. 另外提醒下读者不要对go的技巧有什么期待.go这种强调工程上实用性的语言没有奇技淫巧,只有规范,可玩性几乎为0. 本文内容也不多,只有2个篇章,至于语法直接去看Go指南好了,有说明有代码. 工具链 这部分讲官方提供的工具和如何配置工作环境 网络编程实战 这部分并不是讲socket,而是如何使用一些成熟框架构造接口服务 "},"工具链/":{"url":"工具链/","title":"工具链","keywords":"","body":"go语言的工具链 go语言的周边工具都是官方提供的,使用相同的工具可以让多人合作的项目有更好的代码规范性,更加便于后期维护.(C语言不同社区如此分裂也和没有官方的工具链有关) 这些工具链主要提供的功能是: 编译源码 依赖控制 代码风格控制 代码测试 log输出 程序配置读入 当然针对一些特殊需求和不同的编辑器也会有一些其他的工具.这些如有必要我们也会在相应的单元中介绍 "},"工具链/go语言的编译器和编译环境搭建.html":{"url":"工具链/go语言的编译器和编译环境搭建.html","title":"go语言的编译器和编译环境搭建","keywords":"","body":"go语言的编译器和编译环境搭建 就像c语言需要gcc,同样作为静态语言,go语言也需要现有编译器才可以编译源码. 我们可以去go语言的官网下载安装,如果和我一样是mac用户,可以借助Homeberry安装 brew install golang 装好后并不是直接可以用,go语言有这么几个比较重要的环境变量需要设置 GOPATH 用于标明GO语言的默认全局编译和安装工作目录,类似python中的site-packages,其中会有src,pkg和bin三个目录,分别是项目的源码,库文件和可执行文件. GOROOT 用于标明Go语言的安装目录 其他的还有一些我们用到的时候再说,如果要查看当前安装环境下与go语言有关的全部环境变量,可以使用命令 go env查看. 同时为了方便起见,也应该向环境变量中的PATH中添加$GOPATH/bin,这样全局安装的go程序就可以直接执行了. 编译和解释 从python,js这类动态语言过来的同学可能有些不理解什么是编译器.在动态语言中有解释器用于解释执行源码,即将源码先翻译为二进制码,然后解释器将这些二进制码通过调用内部的对应虚拟机执行.向java虽然说自己是静态语言,但实质上也是这个流程,只是它是按模块读取二进制码不是逐行读取,并且不允许运行时修改而已. 而类似C语言,Go语言这类则是完全不一样的路数--编译器会先读取源码,做好类型检测,语法检测,然后将其直接编译为机器可以执行的机器码,然后通过链接的方式将不容模块链接合并成动态库,静态库或者可执行文件. 因此python执行总是python xxxx.py,js执行总是node xxx.js,java执行也总是java xxxx.jar,毕竟他们其实是使用解释器解释程序让他在虚拟机中执行;而C,go这类则是编译出个叫hello的程序后,直接使用./hello就可以执行了,因为编译好的程序是操作系统本身就可以执行的程序. helloworld 我们惯例的从一个helloworld开始这一系列.本文的例子全部是在$GOPATH下编程,不在其中编程可以看下一篇. package main import \"fmt\" func main() { fmt.Println(\"Hello, 世界 Golang!\") } 请在你的$GOPATH/src下新建一个文件夹helloworld,之后再在其中新建一个文件helloworld,go,将上面的源码复制进去即可. 这个例子中我们的package是main,这就标志着它是一个可执行文件的源码入口,同时也意味着这个项目的源码是一个可执行文件的源码. 一个可执行文件源码必须由一个带有main函数,且package为main的文件,这个文件就是其入口文件. 编译可执行文件 go编译程序使用命令go build [-o output] [-i] [build flags] [packages] 在我们这个helloworld项目来说,只需要在$GOPATH目录下使用go build helloworld即可,这种做法构造的可执行程序会在$GOPATH目录下,指定-o可以改变路径.另一种做法是cd到项目文件夹根目录,直接执行go build,这种方式会编译到项目根目录. 安装helloworld程序 如果我们希望编译好后可执行文件自动放入$GOPATH/bin文件夹,可以使用go install [-i] [build flags] [packages]. 和go build一样有两种方式 在$GOPATH目录下使用go install helloworld cd到项目文件夹根目录,直接执行go install 执行程序 由于我们的$GOPATH/bin已经在PATH中,因此可以直接执行 ~ helloworld Hello, 世界 Golang! 静态库 go语言早期只支持静态库,我们的第二个例子就来构建一个静态库.这个静态库实现牛顿法求平方根. package mymath func Sqrt(x float64) float64 { z:=1.0 for i:=0;i go代码要求模块的: package为短命名且不和标准库冲突. 函数使用驼峰命名法 接口(interface)以er结尾 结构体名应该是名词或名词短语 go中判断一个函数或结构体是否模块外可见使用的是首字母来区分,如果是大写则为可见,否则不可见.像上面的代码我们的Sqrt函数就是可见的. 我们将这个文件命名为mymath.go,放在$GOPATH/src/my/mymath目录下. 编译静态库 编译静态库一样是两种方式: 在$GOPATH下使用go install my/mymath命令 在$GOPATH/src/my/mymath目录下使用go install命令 这两种方式都可以在$GOPATH/pkg/{platform}目录下的my文件夹下生成mymath.a静态库.这个platform取决于你使用的是什么操作系统什么cpu,比如我是mac,那就是darwin_amd64. 调用静态库 调用静态库也很简单,只需要使用import语句即可 package main import ( \"fmt\" mymath \"my/mymath\" ) func main() { fmt.Println(mymath.Sqrt(2)) } 这个项目我们放在$GOPATH/src/calculsqrt下,文件取名为main.go 之后使用go install命令安装这个项目,我们可以看到它被正常编译了. 这边来解释下import命令,import使用语法 import ( ... [alias_name] \"path/to/lib\" ) 来调用可用的静态库,其搜索路劲按顺序依次为 本地vendor文件夹(这个在下一节依赖控制部分讲) 环境变量GOPATH下 环境变量GOROOT下 如果我们给库定义了别名,那么我们就可以在后面的代码中使用这个别名代表这个库,这就有点像python中的import xxx as yyy 动态库 (golang 1.8+) 在go 1.8版本加入了对动态库的支持,使用标准库plugin来实现.目前它还只支持linux和mac.是的,动态库在go语境下叫做插件,这主要是为了和c语言的动态库做区分,事实上go对C语言相当亲和,go代码可以直接编译为c语言的动态库.这个后面再说. 编译动态库 我们还是以这个牛顿法求开根号的项目为例子.这回我们不能直接用使用上面的代码,必须将package改为main package main func Sqrt(x float64) float64 { z:=1.0 for i:=0;i 这个文件我们放在$GOPATH/src/calculsqrt_plugin文件夹下,使用如下命令编译 go build -buildmode=plugin -o sqrt.so 这样就可以编译一个插件了,执行上面的命令后我们可以再这个文件夹下获得动态库文件sqrt.so 使用动态库 在相同文件夹下我们写一个入口模块main.go package main import ( \"fmt\" \"plugin\" ) func main() { // 加载动态库 module, err := plugin.Open(\"./sqrt.so\") if err != nil { fmt.Println(\"plugin load error\") } else { //在动态库中查找方法 Sqrt, err := module.Lookup(\"Sqrt\") if err != nil { fmt.Println(\"no Sqrt in plugin\") } else { //为函数赋予类型后再调用 fmt.Println(Sqrt.(func(float64) float64)(2)) } } } 可以看到动态库的使用和python中使用ctype调用c语言的动态库很像,需要先加载,再找到对应的函数,然后还要为这个函数赋予一个类型,最后才能调用. 之后就像之前的程序编译一样直接使用go install安装就好,可以看到程序正常编译和安装了,执行calculsqrt_plugin也可以获得正确答案. 相对而言我还是更加推荐使用静态库的,go的插件写法复杂不说,编译后项目的大小也比不用的大,除非希望借助插件实现动态热更新,否则完全找不到使用的理由.而热更新其实完全可以借助docker swarm这样的集群工具实现 交叉编译 go的另一大卖点是交叉编译,也就说我在mac上可以直接编译windows可以执行的程序.目前这一功能在各种语言中都属于相当先进的特性. 而使用的方式也是相当简单只要在编译时指定特定环境变量即可: GOOS：目标操作系统 GOARCH：目标操作系统的架构 下面是目前支持的交叉编译组合: OS ARCH OS version linux 386 / amd64 / arm >= Linux 2.6 darwin 386 / amd64 OS X (Snow Leopard + Lion) freebsd 386 / amd64 >= FreeBSD 7 windows 386 / amd64 >= Windows 2000 无论是go build还是go install都可以通过指定这两个环境变量编译为对应平台的程序.它会在对应的文件夹下生成一个平台名+cpu命令集名的文件夹,用于存放跨平台的库或者程序,这其实在编译静态库的部分我们已经见识过了. 我们以上面的calculsqrt为例,在项目根目录执行命令GOOS=windows GOARCH=amd64 go build就可以在项目根目录获得windows上可执行的exe文件了. 减小可执行文件体积 go的编译速度很快,算是它的一大卖点,但比较让人诟病的就是它编译出来的可执行文件比较大,虽说硬盘是计算机上最不值钱的东西,但毕竟还是有一些场景我们不得不考虑可执行文件的大小比如在arm单片机上做些服务.我们有两种途径减小文件大小 编译时指定一些参数 我们可以指定-ldflags \"-s -w\"来减小编译出来的可执行文件大小,代价就是失去一些功能和信息.-s的作用是去掉符号信息.-w的作用是去掉调试信息.因此这种方式减小文件大小比较适合在已经经过充分测试的发行版上使用.这种方式经过我测试压缩我们的calculsqrt项目,从原始的2.25m压缩到了1.61m 使用upx 丑话说前面,upx并不保证可以在各个平台上正常执行,因此这个方案并不稳.upx是一个压缩工具,可以直接压缩可执行文件并且多数情况下不会影响其执行(但执行开始时会有一个解压过程).我们可以去项目的release栏目下下按自己的开发平台下载这个工具,并将其加入到PATH环境变量下. upx -9 -o $output $target 其中9是压缩等级,压缩等级为1到9,9是压缩率最大的等级,压缩原始可执行文件后的可执行文件大小为1.12m;压缩经过-ldflags缩减过的可执行文件后其大小为576k.无论如何upx都是一个值得一试的工具,它确实可以解决问题. Linux/mac下借助bash脚本实现选择平台编译 为了不用每次都敲一遍相同的代码我们可以使用bash来简化这个操作. make.sh ASSETS=\"bin\" GOARCHS=(\"386\" \"amd64\") GOOSS=(\"linux\" \"darwin\" \"windows\") export GO111MODULE=\"on\" # Set the GOPROXY environment variable export GOPROXY=\"https://goproxy.io\" case $(uname) in Darwin) case $(uname -m) in x86_64) cmd=\"mac\" ;; *) cmd=\"mac32\" ;; esac ;; *) case $(uname -m) in x86_64) cmd=\"linux64\" ;; *) cmd=\"linux32\" ;; esac ;; esac cmd=\"mac\" name=\"calculsqrt\" if test $# -eq 0; then cmd=\"mac\" elif test $# -eq 1; then cmd=$1 elif test $# -eq 2; then cmd=$1 name=$2 else echo \"args too much\" exit 0 fi if ! test -d $ASSETS; then mkdir $ASSETS fi case $cmd in all) for goarch in ${GOARCHS[@]}; do for goos in ${GOOSS[@]}; do export GOARCH=$goarch export GOOS=$goos target=\"$ASSETS/$GOOS-$GOARCH\" echo \"---------$target----------------\" if ! test -d $target; then mkdir $target fi case $goos in windows) go build -o $target/$name.exe ;; *) go build -o $target/$name ;; esac done done ;; win32) export GOARCH=\"386\" export GOOS=\"windows\" target=\"$ASSETS/$GOOS-$GOARCH\" if ! test -d $target; then mkdir $target fi go build -o $target/$name.exe ;; win64) export GOARCH=\"amd64\" export GOOS=\"windows\" target=\"$ASSETS/$GOOS-$GOARCH\" if ! test -d $target; then mkdir $target fi go build -o $target/$name.exe ;; mac) export GOARCH=\"amd64\" export GOOS=\"darwin\" target=\"$ASSETS/$GOOS-$GOARCH\" if ! test -d $target; then mkdir $target fi go build -o $target/$name ;; mac32) export GOARCH=\"386\" export GOOS=\"darwin\" target=\"$ASSETS/$GOOS-$GOARCH\" if ! test -d $target; then mkdir $target fi go build -o $target/$name ;; linux32) export GOARCH=\"386\" export GOOS=\"linux\" target=\"$ASSETS/$GOOS-$GOARCH\" if ! test -d $target; then mkdir $target fi go build -o $target/$name ;; linux64) export GOARCH=\"amd64\" export GOOS=\"linux\" target=\"$ASSETS/$GOOS-$GOARCH\" if ! test -d $target; then mkdir $target fi go build -o $target/$name ;; linuxarm) export GOARCH=\"arm\" export GOOS=\"linux\" target=\"$ASSETS/$GOOS-$GOARCH\" if ! test -d $target; then mkdir $target fi go build -o $target/$name ;; *) echo \"unknown cmd $cmd\" ;; esac 这个脚本允许带两个参数==平台和编译后的名字 windows下借助powershell选择编译的平台 make.ps1 $ASSETS = \"bin\" $GOARCHS = \"386\", \"amd64\" $GOOSS = \"linux\", \"darwin\", \"windows\" $env:GO111MODULE=\"on\" # Set the GOPROXY environment variable $env:GOPROXY=\"https://goproxy.io\" $cmd = \"win64\" $name = \"calculsqrt\" if ($args.Count -eq 0){ $cmd = \"win64\" }elseif ($args.Count -eq 1){ $cmd = $args[0] }elseif ($args.Count -eq 2){ $cmd = $args[0] $name = $args[1] }else{ echo \"args too much\" exit } if (!(Test-Path $ASSETS)) { mkdir $ASSETS } if ($cmd -eq \"all\"){ foreach ($env:GOARCH in $GOARCHS) { foreach ($env:GOOS in $GOOSS){ $target = \"$ASSETS/$env:GOOS-$env:GOARCH\" if (!(Test-Path $target)){ mkdir $target } if ($env:GOOS -eq \"windows\"){ go build -o $target/$name.exe }else { go build -o $target/$name } } } }elseif ($cmd -eq \"win32\") { $env:GOARCH=\"386\" $env:GOOS=\"windows\" $target = \"$ASSETS/$env:GOOS-$env:GOARCH\" if (!(Test-Path $target)){ mkdir $target } go build -o $target/$name.exe }elseif ($cmd -eq \"win64\") { $env:GOARCH=\"amd64\" $env:GOOS=\"windows\" $target = \"$ASSETS/$env:GOOS-$env:GOARCH\" if (!(Test-Path $target)){ mkdir $target } go build -o $target/$name.exe }elseif ($cmd -eq \"mac\") { $env:GOARCH=\"amd64\" $env:GOOS=\"darwin\" $target = \"$ASSETS/$env:GOOS-$env:GOARCH\" if (!(Test-Path $target)){ mkdir $target } go build -o $target/$name }elseif ($cmd -eq \"mac32\") { $env:GOARCH=\"386\" $env:GOOS=\"darwin\" $target = \"$ASSETS/$env:GOOS-$env:GOARCH\" if (!(Test-Path $target)){ mkdir $target } go build -o $target/$name }elseif ($cmd -eq \"linux32\") { $env:GOARCH=\"386\" $env:GOOS=\"linux\" $target = \"$ASSETS/$env:GOOS-$env:GOARCH\" if (!(Test-Path $target)){ mkdir $target } go build -o $target/$name }elseif ($cmd -eq \"linux64\") { $env:GOARCH=\"amd64\" $env:GOOS=\"linux\" $target = \"$ASSETS/$env:GOOS-$env:GOARCH\" if (!(Test-Path $target)){ mkdir $target } go build -o $target/$name }elseif ($cmd -eq \"linuxarm\") { $env:GOARCH=\"arm\" $env:GOOS=\"linux\" $target = \"$ASSETS/$env:GOOS-$env:GOARCH\" if (!(Test-Path $target)){ mkdir $target } go build -o $target/$name }else{ echo \"unknown cmd $cmd\" } "},"工具链/依赖控制.html":{"url":"工具链/依赖控制.html","title":"依赖控制","keywords":"","body":"依赖控制 go语言在1.11之前都是出了名的依赖控制稀烂,虽然已经有了但就是缺那么点意思.它只实现了包下载,并没实现真正的依赖管理尤其是版本管理,而且在1.11之前我们必须依赖GOPATH,也就是说我们就像在python中永远不用虚拟环境,并且写代码还必须在site-packages中一样.在Go 1.6中加入了vendor的支持,我们可以将依赖的包放在项目根目录下的vendor文件夹下,实现版本管理,但项目本身还是需要在$GOPATH/src下.直到go 1.11推出了go modules才算真正意义上获得了依赖控制的能力. 初始化项目 现在我们可以在任意我们希望的地方开始我们的项目了. 首先我们在随便一个文件夹初始化我们的项目 go mod github.com/tutorialforgolang/calculsqrt 为什么取这个名字,因为我们会将这个项目上传至github.com/tutorialforgolang/calculsqrt.为后续的依赖控制部分提供材料. 在执行好上面一步后我们可以在项目根目录找到一个名为go.mod的文件,其内容为 module github.com/tutorialforgolang/calculsqrt go 1.12 这个文件类似python的requirements.txt我们主要用它来管理依赖 安装依赖 这个项目的外部依赖只有github.com/sirupsen/logrus 最简单的方式我们可以使用go get github.com/sirupsen/logrus来安装.如果要指定版本可以使用go get github.com/sirupsen/logrus@v1.1.1否则就是默认使用git仓库的master分支. 但更好的方法是将依赖写入go.mod文件. module github.com/tutorialforgolang/calculsqrt require github.com/sirupsen/logrus v1.1.1 go 1.12 这样就可以使用命令go mod download下载或者直接在go build或go install命令时安装依赖了. 安装的依赖会放到$GOPATH/pkg/mod/目录下. 同时go build会编译到项目根目录,而go install则依然会放到GOPATH中,这个需要注意 依赖控制 go.mod通过require,exclude,replace字段管理依赖 require：依赖包列表以及版本,如果我们要的库并没有打出符合标准的tag,那么可以使用master指定主干分支,go-mod会自动为其修改版本为最新的版本号或者最新的版本号-提交时间-git的commit的id组成的字符串作为版本号 exclude：禁止依赖包列表(仅在当前模块为主模块时生效) replace：替换依赖包列表(仅在当前模块为主模块时生效) 其他mod命令包括: 命令 说明 go mod tidy 拉取缺少的模块，移除不用的模块 go mod graph 打印模块依赖图 go mod verify 校验依赖 go mod why 解释为什么需要依赖 go list -m -json all 依赖详情 使用vendor本地化依赖 上面的一套依然是类似使用的python的全局方式安装依赖,如果我希望我的项目在没有GOPATH的情况下也可以编译成功该如何呢? 我们可以使用go mod vendor将download好的依赖拷贝放入项目根目录下的vendor文件夹.这样只要在编译时后面加上-mod=vendor就可以去除对GOPATH的依赖了 按版本项目发布 go语言的依赖系统几乎是绑定在git上的,版本发布使用的是git的tag功能,相当偷懒. 我们改造上面的项目,将其发布到gihub上的对应位置. go要求tag符合类似v0.0.1的形式才是一个版本号标签. 我们在github上新建这个项目,并clone到本地,然后将上面例子的文件都复制到本地的仓库内.ok开始为发布做准备吧 修改.gitignore文件,新增对vendor文件夹和mac操作系统的支持 .... vendor .DS_Store .AppleDouble .LSOverride Icon ._* .DocumentRevisions-V100 .fseventsd .Spotlight-V100 .TemporaryItems .Trashes .VolumeIcon.icns .AppleDB .AppleDesktop Network Trash Folder Temporary Items .apdisk 修改README.md,让它可以明确描述项目信息 当然这也有好处,像github的发布工具也是依赖tag. # calculsqrt go项目使用git的tag功能设定版本的例子 ## version 0.0.2 ## 安装 `go get github.com/tutorialforgolang/calculsqrt@v0.0.2` 在别处随便新建一个项目,按上面的初始化,然后添加依赖 module testcalculsqrt require github.com/sirupsen/logrus v1.1.1 require github.com/tutorialforgolang/calculsqrt v0.0.2 go 1.12 加入入口模块 package main import ( mymath \"github.com/tutorialforgolang/calculsqrt/my/mymath\" log \"github.com/sirupsen/logrus\" ) func main() { log.Info(mymath.Sqrt(2)) } 由上面可以看出 go语言的代码发布由于借助了git工具,所以相当简单,随便一个git仓库都可以用于发布,只要有tag就可以指定版本. 发布的代码除了可以本身是一个pkg外也可以是一个可执行程序,我们可以直接引用其中的pkg,当然这并不推荐,这样包藏得过于隐晦不利于管理 子模块 为了便于组织代码使代码更加清晰,我们常用子模块.子模块是主模块文件夹下的一个带go.mod文件夹,其中没有mainpackage,且其中文件的package名就是子模块文件夹的名字.一个典型的子模块go.mod如下: module testlog/logger require github.com/sirupsen/logrus v1.1.1 go 1.12 module名为父模块/子模块 父模快调用子模块 父模快要使用子模块一样需要在require段中添加,一个典型的父模块go.mod如下: module testlog require ( testlog/logger v0.0.0 ) replace testlog/logger v0.0.0 => ./logger go 1.12 在require段中添加模块后还需要在replace段中指明相对父模快的位置,这样才可以使用 子模块调用子模块 注意,子模块间不能双向引用(钻石引用),如果我们要在一个子模块中引用另一个子模块,和父模块引用子模块一样,在go.mod中replace段中写好相对位置即可 墙! 用go语言体验最差的部分就是很多标准库竟然被墙了,在go1.11中新增了一个环境变量GOPROXY,他可结合开源项目goproxy为我们提供go语言依赖的代理工作,设置这个参数我们就可以用它正确的下载安装依赖了.官方还贴心的架设了一个免费的goproxy服务--https://goproxy.io.感谢~ autoauto- 依赖控制auto - 初始化项目auto - 安装依赖auto - 依赖控制auto - 使用vendor本地化依赖auto - 按版本项目发布auto - 子模块auto - 墙!autoauto 我们要使用这个代理只需要在执行下载之前在 linux/mac下 # Enable the go modules feature export GO111MODULE=on # Set the GOPROXY environment variable export GOPROXY=https://goproxy.io windows下用powershell # Enable the go modules feature $env:GO111MODULE=\"on\" # Set the GOPROXY environment variable $env:GOPROXY=\"https://goproxy.io\" 需要注意powershell需要给予权限才能执行.ps1脚本,开启权限需要admin用户在cmd中执行set-ExecutionPolicy RemoteSigned,然后选择yes即可 "},"工具链/log输出.html":{"url":"工具链/log输出.html","title":"log输出","keywords":"","body":"log输出 虽然go有一个log模块,但太过简陋了,现在比较常见的使用github.com/sirupsen/logrus这个包优势在于全面,支持结构化log,支持log分级,也支持写入文件. 当然在使用docker的条件下log输出到文件并不是一个必要的事情.这个部分的例子子我放在项目的code文件夹下 我通常会为log建立一个单独的子模块logger,这样的好处是不容易冲突.项目的结构是: testlog\\ |-go.mod |-main.go |-logger\\ |-go.mod |-logger.go logger.go package logger import ( logrus \"github.com/sirupsen/logrus\" ) func Init() *logrus.Logger { log := logrus.New() log.SetFormatter(&logrus.JSONFormatter{}) return log } //Logger 默认的logger var Logger = Init() //Log 有默认字段的log var Log = Logger.WithFields(logrus.Fields{ \"common\": \"this is a common field\", }) main.go package main import ( \"testlog/logger\" logrus \"github.com/sirupsen/logrus\" ) func main() { logger.Logger.SetLevel(logrus.InfoLevel) logger.Logger.Info(\"测试\") logger.Log.Info(\"测试\") logger.Logger.WithFields(logrus.Fields{ \"event\": \"field\", }).Info(\"测试 field\") logger.Log.WithFields(logrus.Fields{ \"event\": \"field\", }).Info(\"测试 field\") logger.Logger.SetLevel(logrus.WarnLevel) logger.Logger.Info(\"测试 INFO\") logger.Log.Info(\"测试 INFO\") logger.Logger.Warn(\"测试 warn\") logger.Log.Warn(\"测试 warn\") } 结构化输出 我们只需要设置log对象的.SetFormatter(&logrus.JSONFormatter{})就可以输出json格式的log了.而格式化输出中默认的字段有 level:log等级 time:log的打印时间 msg:Info等方法中填入的字符串 增加字段 我们可以为log对象使用方法 log.WithFields(logrus.Fields{ \"common\": \"this is a common field\", }) 添加字段,这个新对象我们可以拿它再执行Info这类方法来输出log,这样我们就有了两种方法 在需要打log时使用 log.WithFields(logrus.Fields{ \"common\": \"this is a common field\", }).Info(\"msg\") 先定义好默认的字段,再在需要打印log时直接使用这个对象来打印 var logger = log.WithFields(logrus.Fields{ \"common\": \"this is a common field\", }) ... logger.Info(\"msg) 设置level 我们只要使用log实例的.SetLevel(logrus.InfoLevel)方法就可以设置log等级.通常我们会设置在logrus.WarnLevel这一级 另一个log库 在github上另一个以快为特色的log库是go.uber.org/zap,在对性能有更高要求的场景下建议改用这个 "},"工具链/代码风格控制.html":{"url":"工具链/代码风格控制.html","title":"代码风格控制","keywords":"","body":"代码风格控制 Go语言很可能是第一个将代码风格强制统一的语言.一些对于其他语言的编译器完全忽视的问题在Go编译器前就会被认为是编译错误,比如如果花括号新起了一行摆放你就会看到一个醒目的编译错误.这一点会让很多人觉得不可思议.无论喜欢还是讨厌,与其他那些单单编码规范就能写出一本书的语言相比,毫无疑问Go语言的这种做法简化了问题. 个人认为Go的设计者相当现实主义,使用了如此激进的方式强制风格一致,这是为大规模项目提高可维护性的重要特性. 强制性代码规范 命名 命名规则涉及变量,常量,全局函数,结构体,接口,方法等. Go语言从语法层面进行了以下限定: 任何需要对外暴露的名字必须以大写字母开头,不需要对外暴露的则应该以小写字母开头. 软件开发行业最流行的两种命名法分别为骆驼命名法(类似于DoSomething和doSomething)和下划线法(对应为do_something),而Go语言明确宣告了拥护骆驼命名法而排斥下划线法.骆驼命名法在Java和C#中得到官方的支持和推荐,而下划线命名法则主要用在C语言的世界里,比如Linux内核和驱动开发上.在开始Go语言编程时还是忘记下划线法吧. 包命名 保持package的名字和目录保持一致,尽量采取有意义的包名.简短,有意义,尽量和标准库不要冲突.包名应该为小写单词,不要使用下划线或者混合大小写. 文件命名 尽量采取有意义的文件名,简短,有意义,应该为小写单词,使用下划线分隔各个单词. 结构体命名 采用驼峰命名法.首字母根据访问控制大写或者小写. 接口命名 命名规则基本和上面的结构体类型,单个函数的接口名以er作为后缀 变量命名 和结构体类似,变量名称一般遵循驼峰法,首字母根据访问控制原则大写或者小写,但遇到特有名词时,需要遵循以下规则: 如果变量为私有,且特有名词为首个单词,则使用小写,如apiClient 其它情况都应当使用该名词原有的写法,如APIClient,repoID,UserID 错误示例:UrlArray,应该写成urlArray或者URLArray 若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头 常量命名 常量均需使用全部大写字母组成,并使用下划线分词 排列 Go语言甚至对代码的排列方式也进行了语法级别的检查, 约定了代码块中花括号开口需要在行尾. Go语言的这条规则基本上就保证了所有Go代码的逻辑结构写法是完全一致的,也不会再出现有洁癖的程序员在维护别人代码之前非要把所有花括号的位置都调整一遍的问题. 注释 注释起到程序文档的作用,由两种形式： 1.行注释为 // 通用注释为 /**/ 注释不能嵌套在 Rune 或者字符串字面量里,也不能嵌套在其他注释里.不包含新行的通用注释就如同一个空格.其他任何注释就像一个换行符. go的注释和python的docstring类似,也是用于接口描述的工具,因此最好有详细描述,但因为是静态语言,所以其实并不太需要标明参数信息 关键字 下列关键字是保留的不能用作标识符: break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 使用gofmt规范风格 go语言自带的gofmt可以自动检测项目中代码的样式是否符合规范,不符合就会将其重新排版. 使用godoc查看代码文档 前文已经说过go的注释会自动生成文档,要读取这些文档我们需要借助godoc 使用godoc -http=:6060后我们就可以查看标准库和你环境中GOPATH下的包的文档 "},"工具链/代码测试.html":{"url":"工具链/代码测试.html","title":"代码测试","keywords":"","body":"代码测试 go语言提供了go test命令用于做代码测试,主要包括3个功能 单元测试 性能测试 只要项目中以_test为结尾的文件就是测试文件. 单元测试 单元测试的测试用例就是测试模块中以Test开头的函数 我们为mymath添加测试: mymath_test.go /* mymath 一个测试用的模块,其中只有一个Sqrt函数用于牛顿法求开根号. */ package mymath import ( \"math\" \"testing\" ) func TestSqrt(t *testing.T) { type args struct { x float64 } tests := []struct { name string args args want float64 }{ {\"1\", args{1.0}, 1.000}, {\"1\", args{2.0}, 1.414} } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := math.Trunc(Sqrt(tt.args.x)*1e3+0.5) * 1e-3; got != tt.want { t.Errorf(\"Sqrt() = %v, want %v\", got, tt.want) } }) } } 之后使用命令go test -v mymath_test.go就可以测试这个测试模块中的所有单元测试了.其中-v表示测试内容可见. 我们也可以使用-run TestA$来指定只有TestA参与测试 代码覆盖率 go test自带了代码覆盖率工具,只需要 加上flag-cover就行 性能测试 性能测试的测试用例是测试模块中以Benchmark开头的函数,我们来为mymath写一个测试用例 func BenchmarkSqrt(b *testing.B) { Sqrt(2.0) } 之后使用命令go test -v -bench=. benchmark_test.go "},"工具链/程序配置读入.html":{"url":"工具链/程序配置读入.html","title":"程序配置读入","keywords":"","body":"程序配置读入 go语言的主要应用场景是写服务和中间件,这些程序通常都是由一个命令行的命令启动,然后通过指定参数或读入配置文件或环境变量加载启动配置,然后再提供服务.因此读入配置是写go程序的第一步. 通常我们读程序配置有两个步骤: 加载外部数据为配置 验证配置符合预计的要求 这篇的例子在testconfigload 加载外部数据为配置 我们加载外部数据来源一般有如下几个,他们按顺序加载通常是如下顺序: 命令行参数 命令行指定的配置文件 指定环境变量中的配置参数 默认配置文件位置下的配置文件 默认的配置值 越在前面的越会优先覆盖,因此我们通常是先加载后面的然后用前面的一级一级的覆盖.我们可以使用库github.com/spf13/viper ... ConfigViper := viper.New() InitDefaultConfig(ConfigViper) InitFileConfig(ConfigViper) InitEnvConfig(ConfigViper) InitFlagConfig(ConfigViper) ... 加载默认配置 func InitDefaultConfig(ConfigViper *viper.Viper) { ConfigViper.SetDefault(\"Num\", 2) } 加载默认位置文件中的配置 func SetFileConfig(ConfigViper *viper.Viper, file_name string, filePaths []string) { FileConfigViper := viper.New() FileConfigViper.SetConfigName(file_name) for _, file_path := range filePaths { FileConfigViper.AddConfigPath(file_path) } err := FileConfigViper.ReadInConfig() // Find and read the config file if err != nil { // Handle errors reading the config file logger.Logger.Info(\"config file not found: %s \\n\", err) } else { logger.Logger.Info(\"Num in file is %d \\n\", FileConfigViper.Get(\"Num\")) ConfigViper.Set(\"Num\", FileConfigViper.Get(\"Num\")) logger.Logger.Info(ConfigViper.Get(\"Num\")) } } func InitFileConfig(ConfigViper *viper.Viper) { file_name := \"config\" filePaths := []string{\"/etc/appname/\", \"$HOME/.appname\", \".\"} SetFileConfig(ConfigViper, file_name, filePaths) } 加载默认位置的配置需要指定文件名(不包含扩展名)和文件所在的目录,可以一次加入多个目录,它会按照顺序查找执行.这个包支持的配置格式有: JSON TOML YAML HCL envfile 通常我们使用JSON或者YAML居多. 加载环境变量中的配置 func InitEnvConfig(ConfigViper *viper.Viper) { EnvConfigViper := viper.New() EnvConfigViper.SetEnvPrefix(\"calcul\") // will be uppercased automatically EnvConfigViper.BindEnv(\"num\") if EnvConfigViper.Get(\"num\") != nil { ConfigViper.Set(\"Num\", EnvConfigViper.Get(\"num\")) } } 可以为环境变量的参数设置前缀,这样可以用于区分不同的应用,需要注意环境变量字符串都是大写. 加载命令行指定的配置 func InitFlagConfig(ConfigViper *viper.Viper) { num := pflag.IntP(\"num\", \"n\", 0, \"要计算平方的值\") confPath := pflag.StringP(\"config\", \"c\", \"\", \"配置文件位置\") pflag.Parse() if *confPath != \"\" { p, err := pathlib.New(*confPath).Absolute() if err != nil { logger.Logger.Info(\"指定的配置文件获取绝对位置失败\") } else { if p.Exists() && p.IsFile() { filenameWithSuffix := path.Base(*confPath) fileSuffix := path.Ext(filenameWithSuffix) file_name := strings.TrimSuffix(filenameWithSuffix, fileSuffix) dir, err := p.Parent() if err != nil { logger.Logger.Info(\"指定的配置文件获取父文件夹位置失败\") } else { filePaths := []string{dir.Path} SetFileConfig(ConfigViper, file_name, filePaths) } } } } if *num != 0 { ConfigViper.Set(\"Num\", *num) // same result as next line } } 相对来说命令行加载配置会略微复杂一些,我们需要使用github.com/spf13/pflag来配置命令行参数,然后根据需要一条一条的加载到配置中. 通常-c是用于指定配置文件路径的,这就需要我们可以判断路径是否存在,是否是文件.这可以使用github.com/small-tk/pathlib包来做,这个包的接口类似python的pathlib,比较友好,然后复用上面加载默认位置配置文件的方法SetFileConfig来加载配置.注意文件名不能带后缀. 验证配置 我们可以使用github.com/xeipuuv/gojsonschema借助jsonschema来做验证配置,通常因为我们的配置最终会被转成一个struct的实例,因此字段是固定的,但里面的值还是需要检查范围的. const schema = `{ \"description\": \"number\", \"type\": \"object\", \"required\": [ \"Num\"], \"additionalProperties\": false, \"properties\": { \"Num\": { \"type\": \"integer\", \"minimum\": 1, \"description\": \"params\" } } }` func VerifyConfig(conf config) bool { configLoader := gojsonschema.NewGoLoader(conf) schemaLoader := gojsonschema.NewStringLoader(schema) result, err := gojsonschema.Validate(schemaLoader, configLoader) if err != nil { logger.Logger.Error(\"Validate error: %s\", err) return false } else { if result.Valid() { logger.Logger.Info(\"The document is valid\") return true } else { logger.Logger.Info(\"The document is not valid. see errors :\\n\") for _, err := range result.Errors() { // Err implements the ResultError interface logger.Logger.Error(\"- %s\", err) } return false } } } 要检查是否符合需要加载配置和验证配置的配置.验证配置的配置我们使用jsonschema来描述即可 "},"工具链/总结.html":{"url":"工具链/总结.html","title":"总结","keywords":"","body":"总结 go语言的工具是其体系中最重要的一环,现如今已经相对成熟,并且也是因为工具链齐备,go已经在开源领域广泛使用.其依托于git的依赖管理和发布系统很有特色. 另外强力推荐使用vscode作为go的开发工具,只需要安装其插件go就可以相当方便的所有操作都在vscode的界面中执行了.记得装好后去这个页面下载其中连接中的全部依赖,并安装到GOPATH,同时修改好插件的GOPATH.插件GOPATH默认是$HOME/go,这并不灵活 "},"使用Golang搭建后端服务/":{"url":"使用Golang搭建后端服务/","title":"使用Golang搭建后端服务","keywords":"","body":"使用Golang搭建后端服务 go语言现在的主战场就是网络编程.这篇其实主要也是为了讲最常用的go语言网络编程工具. 本文主要讲: 使用gin构造RESTful接口服务 websocekt构造接口服务 grpc构造接口服务 而后端相关的技术有: 关系数据库技术,常见的有PostgreSQL,业务上一般使用orm来操作数据库.常用的orm有gorm 共享内存技术,常见的是Redis,我们使用redis 消息队列技术,常见的有rabbitMQ,我们使用amqp;redis;kafka我们用gopkg.in/confluentinc/confluent-kafka-go.v1/kafka 消息的发布订阅工具,常见的有Redis,rabbitMQ,postgreSQL zmq一种基于通信模式的消息组件框架 webrtc一种在浏览器端也有实现的p2p即时通信技术 由于go语言标准库的log工具比较弱,我们有时用logrus来代替 标准库的json性能比较差,我们有时会用github.com/json-iterator/go替代 有时我们也会考虑使用msgpack代替json作为表现层协议 标准库没有原生的协程池,我们有时用ants "},"使用Golang搭建后端服务/RESTful接口服务.html":{"url":"使用Golang搭建后端服务/RESTful接口服务.html","title":"RESTful接口服务","keywords":"","body":"使用Go构建RESTful接口服务 Go有很多优秀的http服务框架,目前用的最广的是Gin,本文也将基于Gin来讲如何使用go语言构建RESTful接口服务. 先来一个helloworld简单了解下通常go语言项目的结构和gin的基本用法 helloworld 一个最基本的项目大致是这样一个结构: |--assets--| | |--server //编译好的服务执行程序 | |--go.mod //模块信息描述依赖 |--helloworld.go //源码 |--makefile //编译流程控制 helloworld.go package main import ( \"github.com/gin-gonic/gin\" ) const ( ADDRESS = \"0.0.0.0:5000\" ) func main() { router := gin.Default() router.GET(\"/ping\", func(ctx *gin.Context) { ctx.JSON(200, gin.H{ \"message\": \"pong\", }) }) router.Run(ADDRESS) // listen and serve on 0.0.0.0:8080 } go.mod module c0 require ( github.com/gin-contrib/sse v0.0.0-20190301062529-5545eab6dad3 // indirect github.com/gin-gonic/gin v1.3.0 github.com/golang/protobuf v1.3.1 // indirect github.com/mattn/go-isatty v0.0.7 // indirect github.com/ugorji/go/codec v0.0.0-20190320090025-2dc34c0b8780 // indirect gopkg.in/go-playground/validator.v8 v8.18.2 // indirect gopkg.in/yaml.v2 v2.2.2 // indirect ) go 1.12 makefile ASSETS=assets server: helloworld.go go build -o $(ASSETS)/server 如果我们要为其添加组件,应该以子模块的形式添加. 为gin写一个插件 Gin的结构类似koa也是洋葱皮结构,它使用ctx.Next()来区分请求和响应,一个典型的的插件如下c1 这个插件的作用是给所有的response的headers体内加上author:hsz 我们在helloworld的基础上个增加一个插件子模块:middleware middleware/useless.go package middleware import ( \"log\" \"github.com/gin-gonic/gin\" ) //UselessMiddleware 没什么用的中间件 func UselessMiddleware(name string) gin.HandlerFunc { return func(ctx *gin.Context) { log.Println(\"Hello \", name) ctx.Writer.Header().Set(\"Author\", name) ctx.Next() log.Println(\"bye \", name) } } 使用这个插件只需要使用Use方法即可. package main import ( \"c1/middleware\" \"github.com/gin-gonic/gin\" ) const ( ADDRESS = \"0.0.0.0:5000\" ) func main() { router := gin.Default() somemid := middleware.UselessMiddleware(\"hsz\") router.Use(somemid) router.GET(\"/ping\", func(ctx *gin.Context) { ctx.JSON(200, gin.H{ \"message\": \"pong\", }) }) router.Run(ADDRESS) // listen and serve on 0.0.0.0:8080 } 一般来说用gin不太需要用第三方插件,要用插件也是自己写为主.我们之前只用了一个第三方插件github.com/toorop/gin-logrus,因为我们的业务是将log打在stdout,通过docker管理服务,并且使用ELK工具组收集log数据.而这套需要输出的格式为json,所以我们才使用了这个插件配合logrus实现json格式输出. 路由组 gin对路由分组的支持是原生的并不需要插件,这就方便我们基于资源划分模块构建RESTful接口了,下面C2是一个典型的RESTful接口,用于描述用户. 路由 func main() { gin.SetMode(gin.ReleaseMode) router := gin.New() router.Use(ginlogrus.Logger(logger.Logger), gin.Recovery()) userlistsource := sources.UserListSource{} usersource := sources.UserSource{} user := router.Group(\"/user\") { user.POST(\"/\", userlistsource.Post) user.GET(\"/:id\", usersource.Get) user.PUT(\"/:id\", usersource.Put) user.DELETE(\"/:id\", usersource.Delete) } userpasswordsource := sources.UserPassWordSource{} userpassword := router.Group(\"/user-password\") { userpassword.POST(\"/\", userpasswordsource.Post) userpassword.PUT(\"/:id\", userpasswordsource.Put) } userpermissionsource := sources.UserPermissionSource{} userpermission := router.Group(\"/user-permission\") { userpermission.POST(\"/\", userpermissionsource.Post) userpermission.DELETE(\"/:id\", userpermissionsource.Delete) } authsource := sources.AuthSource{} auth := router.Group(\"/auth\") { auth.POST(\"/\", authsource.Post) auth.GET(\"/\", authsource.Get) } permissionlistsource := sources.PermissionListSource{} permission := router.Group(\"/permission\") { permission.GET(\"/\", permissionlistsource.Get) } logger.Logger.Info(\"start @\", ADDRESS) router.Run(ADDRESS) // listen and serve on 0.0.0.0:8080 } 上面我们使用router.Group划分资源,并将对应资源对象的对应方法绑定到不同的子路径和对应HTTP方法. sources 一个source可以这样写 //UserSource 用户资源 type UserSource struct { } //Get 根据id获取用户信息 func (u UserSource) Get(ctx *gin.Context) { id := ctx.Param(\"id\") logger.Logger.Info(id) ctx.JSON(200, gin.H{ \"id\": id, \"method\": \"GET\"}) } //Put 根据id和body修改用户信息 func (u UserSource) Put(ctx *gin.Context) { id := ctx.Param(\"id\") logger.Logger.Info(id) ctx.JSON(200, gin.H{ \"id\": id, \"method\": \"PUT\"}) } //Delete 根据id删除用户信息 func (u UserSource) Delete(ctx *gin.Context) { id := ctx.Param(\"id\") logger.Logger.Info(id) ctx.JSON(200, gin.H{ \"id\": id, \"method\": \"DELETE\"}) } 上面我们我们使用值绑定绑定方法是因为我们的UserSource是一个空的结构. "},"使用Golang搭建后端服务/GRpc接口服务.html":{"url":"使用Golang搭建后端服务/GRpc接口服务.html","title":"GRpc接口服务","keywords":"","body":"Grpc接口服务 GRpc正如其名,是一种RPC.它实际上和RESTful接口在功能上是相近的,本质都是一种请求响应模式的服务.只是作为一个RPC,GRpc一般描述动作而非资源,并且它可以返回的不光是一个数据,而是一组流数据. GRpc是一种跨语言的Rpc,它建立在http2上使用protobuf作为结构化数据的序列化工具, 它有4种形式: 请求-响应 请求-流响应 流请求-响应 流请求-流响应 其基本使用方式是: 服务端与客户端开发者协商创建一个protobuf文件用于定义rpc的形式和方法名以及不同方法传输数据的schema 服务端实现protobuf文件中定义的方法 客户端调用protobuf文件中定义的方法 在go中我们需要使用包google.golang.org/grpc,google.golang.org/genproto和github.com/golang/protobuf/protoc-gen-go来实现上面的三个步骤.需要注意,这两个包都是被墙着的,而且实测用goproxy都没救,只能clone下来后改路劲install,注意安装顺序,先安装github.com/golang/protobuf/protoc-gen-go,google.golang.org/genproto再装google.golang.org/grpc,另外就是google.golang.org/grpc和google.golang.org/genprotoclone下来后记得改名字 请求-响应 这个例子C0我们来实现一个简单的服务--输入一个数,输出这个数的平方 最终整个项目的结构 go语言毕竟静态语言,不似动态语言这么灵活,尤其它的包引入机制并不先进,也就比c语言好那么一点.因此必须使用瀑布式的开发流程也就是必须先设计后实现,无法边写边设计. 我们使用go 1.11 新加入的特性module来构建项目c0,这个项目中会有一个子模块c0/squarerpc_service用于存放由protobuf编译来的go模块文件.因为有子模块在其中,我们就需要关注下项目的结构了,否则会无法编译. |--bin--| | |--server //编译好的服务软件 | |--client //编译好的客户端软件 | |--client--| | |--client.go //客户端源码 | |--schema--| | |--square_service.proto // 定义的protobuf | |--squarerpc_service--| | |--square_service.pb.go //由square_service.proto编译过来的go模块 | |--go.mod //定义子模块squarerpc_service的依赖关系 | |--go.mod //定义项目的依赖关系 |--makefile //定义编译过程 |--server.go //服务端源码 需要注意的是为了可以引用本地的子模块,父模块的go.mod需要使用replace声明将子模块替换为本地. 父级go.mod module c0 require ( c0/squarerpc_service v0.0.0 github.com/golang/protobuf v1.3.1 google.golang.org/grpc v1.19.0 ) replace c0/squarerpc_service v0.0.0 => ./squarerpc_service go 1.12 创建一个protobuf文件 go语言已经强制使用大写字母作为public的标志,那我们定义protobuf的时候也最好按这个来定义,否则在go中也会强制转成首字母大写,造成不一致. syntax = \"proto3\"; package squarerpc_service; service SquareService { rpc Square (Message) returns (Message){} } message Message { double Message = 1; } 在这个项目中我们使用命令 protoc -I schema schema/square_service.proto --go_out=plugins=grpc:squarerpc_service -I指定了protobuf文件所在的文件夹 --go_out=plugins=grpc指定了是grpc使用,:squarerpc_service则是指定了编译后的目标文件夹 服务端实现定义的方法 go的服务端写起来还是比较简单的 package main import ( \"context\" \"log\" \"net\" pb \"c0/squarerpc_service\" grpc \"google.golang.org/grpc\" ) const ( // server port 5000 ADDRESS = \"0.0.0.0:5000\" ) // server 结构体用于实现pb中的SquareService. type server struct{} // 为结构体绑定要实现的方法 func (s *server) Square(ctx context.Context, in *pb.Message) (*pb.Message, error) { log.Printf(\"Received: %v\", in.Message) return &pb.Message{Message: in.Message * in.Message}, nil } func main() { lis, err := net.Listen(\"tcp\", ADDRESS) if err != nil { log.Fatalf(\"failed to listen: %v\", err) } log.Println(\"server started @\", ADDRESS) s := grpc.NewServer() pb.RegisterSquareServiceServer(s, &server{}) if err := s.Serve(lis); err != nil { log.Fatalf(\"failed to serve: %v\", err) } } 首先是定义一个空的结构server,并为其绑定上我们要实现的pb文件中定义的方法实现.注意返回的是结构的实例地址而非实例 然后使用net模块的Listen方法创建一个网络监听器lis 之后使用grpc.NewServer()创建一个服务器s 使用pb中的pb.RegisterSquareServiceServer(s, &server{})方法把s和一个server结构体的实例地址绑定 最后服务器s使用s.Serve(lis)方法绑定监听器 客户端实现方式 客户端一块主要是要关注下连接的退出和过期后的关闭上下文的操作.这边都是用defer关键字实现的. package main import ( \"context\" \"log\" \"os\" \"strconv\" \"time\" pb \"c0/squarerpc_service\" grpc \"google.golang.org/grpc\" ) const ( //server address ADDRESS = \"localhost:5000\" ) func main() { // 连接到服务器. conn, err := grpc.Dial(ADDRESS, grpc.WithInsecure()) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() // 创建client对象 c := pb.NewSquareServiceClient(conn) // 构造要发送的请求 query := 2.0 if len(os.Args) > 1 { query, err = strconv.ParseFloat(os.Args[1], 64) if err != nil { log.Fatalf(\"query can not parse from string: %v\", err) panic(err) } } // 设置请求上下文的过期时间 ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() // 调用rpc的函数 r, err := c.Square(ctx, &pb.Message{Message: query}) if err != nil { log.Fatalf(\"could not call: %v\", err) } log.Printf(\"Result: %f\", r.Message) } 使用makefile流程化编译 都写好了后来定义一个makefile用于流程化编译 ASSETS=assets default: server client squarerpc_service/square_service.pb.go: schema/square_service.proto squarerpc_service/go.mod protoc -I schema schema/square_service.proto --go_out=plugins=grpc:squarerpc_service server: squarerpc_service/square_service.pb.go server.go go build -o $(ASSETS)/server client: squarerpc_service/square_service.pb.go client/client.go go build -o $(ASSETS)/client client/client.go 这个makefile肯定不是生产环境可以用的,它都没有做针对部署目标的交叉编译.这边写出来只是给个样例. 请求-流响应 这种需求比较常见,有点类似,python中的range函数,它生成的是一个流而非一个数组,它会一次一条的按顺序将数据发送回请求的客户端. 这个例子C1实现了给出一个正整数,它会返回从0开始到它为止的每个整数的平方. 修改protobuf文件 ... service SquareService { rpc RangeSquare (Message) returns (stream Message){} } ... 我们只要在返回值前面声明stream就可以定义一个流响应 修改服务端 // 第一位为请求,第二位为流对象,用于发送回消息 func (s *server) RangeSquare(in *pb.Message, stream pb.SquareService_RangeSquareServer) error { limit := int(in.Message) for i := 0; i go的流响应主要是靠调用参数中的stream的Send方法实现的. 修改客户端 stream, err := client.RangeSquare(ctx, &pb.Message{Message: query}) if err != nil { log.Fatalf(\"could not call: %v\", err) } for { result, err := stream.Recv() if err != nil { if err == io.EOF { break } else { log.Fatalf(\"%v.RangeSquare(_) = _, %v\", client, err) } } log.Printf(\"Result: %f\", result.Message) } 客户端调用在前面没什么不同,只是返回的值是一个stream,我们需要使用for语句不断调用stream.Recv()直到返回的err为io.EOF为止. 流请求-响应 这种需求不是很多见,可能用的比较多的是收集一串数据后统一进行处理吧,流只是可以确保是同一个客户端发过来的而已. 这个例子C2实现了传过来一串数,之后返回他们的平方和 修改protobuf文件 ... service SquareService { rpc SumSquare (stream Message) returns (Message){} } ... 我们只要在请求前面声明stream就可以定义一个流响应 修改服务端 func (s *server) SumSquare(stream pb.SquareService_SumSquareServer) error { var sum float64 = 0.0 for { data, err := stream.Recv() if err != nil { if err == io.EOF { return stream.SendAndClose(&pb.Message{Message: sum}) } if err != nil { return err } } else { sum += data.Message * data.Message } } } 请求流的返回就是一个error,操作其实就在stream上,接收使用Recv(),返回使用SendAndClose() 修改客户端 stream, err := c.SumSquare(ctx) if err != nil { log.Fatalf(\"could not call: %v\", err) } for i := 0; i 请求也是类似,由于go的语法表现力不足,所以只能调用后返回一个流对象,再使用流的CloseAndRecv()手工结束流后等待结果返回. 流请求-流响应 将上面两种方式结合起来,就是我们的第四种方式,请求为一个流,响应也是流.这两个流可以是相互交叉的也可以是请求完后再返回一个流.他们在写pb文件时是相同的写法 service SquareService { rpc StreamrangeSquare (stream Message) returns (stream Message){} } 请求流完成后返回流 修改服务端 func (s *server) StreamrangeSquare(stream pb.SquareService_StreamrangeSquareServer) error { l := list.New() for { in, err := stream.Recv() if err != nil { if err == io.EOF { break } else { return err } } else { l.PushBack(in.Message * in.Message) } } for e := l.Front(); e != nil; e = e.Next() { stream.Send(&pb.Message{Message: e.Value.(float64)}) } return nil } 修改客户端 // 调用rpc的函数 stream, err := c.StreamrangeSquare(ctx) if err != nil { log.Fatalf(\"could not call: %v\", err) } waitc := make(chan struct{}) go func() { for { in, err := stream.Recv() if err != nil { if err == io.EOF { // read done. close(waitc) return } else { log.Fatalf(\"Failed to receive a note : %v\", err) } } else { log.Printf(\"Got message %f\", in.Message) } } }() limit := int(query) for i := 0; i 客户端有点特殊,使用子协程处理读入,主协程处理请求流,通过阻塞信道waitc来等待读取请求完成,当读取完成后协程会关闭waitc,这样阻塞取消程序就正常结束了. 请求的进行中就返回响应 修改服务端 func (s *server) StreamrangeSquare(stream pb.SquareService_StreamrangeSquareServer) error { for { in, err := stream.Recv() if err != nil { if err == io.EOF { return nil } else { return err } } else { err := stream.Send(&pb.Message{Message: in.Message * in.Message}) if err != nil { return err } } } return nil } "},"使用Golang搭建后端服务/Websocket接口服务.html":{"url":"使用Golang搭建后端服务/Websocket接口服务.html","title":"Websocket接口服务","keywords":"","body":"使用Golang构建Websocket接口服务 Golang可以使用gorilla/websocket这个框架来实现websocket接口的构造.这个框架可以用于写客户端和服务器. 我们依然从一个helloworld开始.这个例子我们在客户端连同服务端后立即发送一个helloworld消息给后端服务器,服务器接到后则返回一个helloworld消息给客户端. 客户端在接收到服务器消息后发送一个close消息给服务器,服务器就断开和客户端的连接. 服务端 package main import ( \"flag\" \"log\" \"net/http\" \"github.com/gorilla/websocket\" ) var addr = flag.String(\"addr\", \"localhost:5000\", \"http service address\") var upgrader = websocket.Upgrader{} // use default options func helloworldWsHanddler(ws *websocket.Conn) { for { mt, message, err := ws.ReadMessage() if err != nil { log.Println(\"read:\", err) break } else { switch mt { case websocket.CloseMessage: { log.Println(\"get close signal\") break } case websocket.PingMessage, websocket.PongMessage: { log.Println(\"get ping pong\") } case websocket.TextMessage: { log.Printf(\"recv: %s\", message) msg := string(message) switch msg { case \"close\": { break } case \"helloworld\": { err = ws.WriteMessage(websocket.TextMessage, []byte(\"Hello World\")) if err != nil { log.Println(\"write:\", err) break } } default: { err = ws.WriteMessage(websocket.TextMessage, []byte(\"unkonwn command\")) if err != nil { log.Println(\"write:\", err) break } } } } case websocket.BinaryMessage: { log.Println(\"not support Binary now\") } default: { log.Println(\"not support now\") } } } } } func helloworldHttpHanddler(w http.ResponseWriter, r *http.Request) { ws, err := upgrader.Upgrade(w, r, nil) if err != nil { log.Print(\"upgrade:\", err) return } defer ws.Close() helloworldWsHanddler(ws) } func main() { flag.Parse() log.SetFlags(0) http.HandleFunc(\"/helloworld\", helloworldHttpHanddler) log.Fatal(http.ListenAndServe(*addr, nil)) } 服务端我们需要用一个http服务器监听一个url.在有客户端访问后,使用websocket.Upgrader{}来将http访问提升为websocket连接.使用 mt, message, err := ws.ReadMessage()来获取消息.返回值的第一项为消息类型,第二项为message体.消息类型包含如下几种: websocket.BinaryMessage字节流数据 websocket.TextMessage文本数据 websocket.PingMessage保持连接用的消息 websocket.PongMessage保持连接用的消息 websocket.CloseMessage关闭信号 而发送回去一般使用的ws.WriteMessage(int , []byte) error来发送消息. 因为mt有多种情况,我们一般使用switch来区分.一般为了可读性我们使用websocket.TextMessage结合json来传递信息; 当然go语言天生亲和protobuf,所以也可以使用websocket.BinaryMessage结合protobuf来传递消息. 客户端 package main import ( \"flag\" \"log\" \"net/url\" \"os\" \"os/signal\" \"time\" \"github.com/gorilla/websocket\" ) var addr = flag.String(\"addr\", \"localhost:5000\", \"http service address\") func main() { flag.Parse() log.SetFlags(0) interrupt := make(chan os.Signal, 1) signal.Notify(interrupt, os.Interrupt) u := url.URL{Scheme: \"ws\", Host: *addr, Path: \"/helloworld\"} log.Printf(\"connecting to %s\", u.String()) ws, _, err := websocket.DefaultDialer.Dial(u.String(), nil) if err != nil { log.Fatal(\"dial:\", err) } defer ws.Close() done := make(chan struct{}) // open后就发送 err = ws.WriteMessage(websocket.TextMessage, []byte(\"helloworld\")) if err != nil { log.Println(\"write:\", err) } go func() { defer close(done) for { mt, message, err := ws.ReadMessage() if err != nil { log.Println(\"read:\", err) return } else { switch mt { case websocket.CloseMessage: { log.Println(\"disconnected\") return } case websocket.PingMessage, websocket.PongMessage: { log.Println(\"get ping pong\") } case websocket.TextMessage: { msg := string(message) log.Printf(\"recv: %s\", msg) return } case websocket.BinaryMessage: { log.Println(\"not support Binary now\") return } default: { log.Println(\"not support now\") return } } } } }() for { select { case 客户端部分与上面也类似.区分好消息类型就行 比较坑的是ws.WriteMessage输入和ws.ReadMessage()都是一个[]byte类型的数据.因此即便是websocket.TextMessage类型的数据也要做好类型转换. Json数据传输 一种更常见的形式是使用结构化数据格式表示一个事件,客户端服务器按事件的不同来进行不同的处理.例子c1就是这个helloworld的改进.顺便我们也把这个代码拆分一下让它更加便于管理. 这个项目被拆分成了如下几个子模块 logger使用github.com/sirupsen/logrus的log模块 config使用github.com/paked/configure加载命令行和config文件的子模块 上面的几个是子模块具有一定的通用性,可以用于设定各种服务的配置. errors用于维护这个项目的所有错误 event事件类型,事件使用json格式 clienthanddler客户端的事件控制逻辑 serverhanddler服务端的事件控制逻辑 在客户端和服务端中都使用定义好的事件结构 type Event struct { EventType string `json:\"name\"` Message string `json:\"message\"` } 来将消息转成事件处理.读取使用 e := event.Event{} ws.ReadJSON(&e) 写使用 message := event.Event{EventType: \"message\", Message: \"unkonwn command\"} err = ws.WriteJSON(message) 广播消息 广播就是向符合条件的连接同时发送相同的消息,也就是发布订阅模式. 下面的例子C2我们就利用http的url构造room的概念来限定广播的范围,进入一个room就相当于订阅了一个topic,离开room也就相当于取消订阅.为此我们构造了两个结构: Exchange 用于管理一个room的订阅,取消订阅,广播消息,其使用github.com/rfyiamcool/syncmap的syncmap.Map结构代替set结构维护客户端的连接.这是标准库sync.Map的一个扩展,是一个线程安全的map结构,我们用它代替set,之所以不用默认的map是因为它不是线程安全的,我们有要定时删除不用room的逻辑,这可能引起资源冲突.不过要注意这个库有些小bug,用的时候要小心.当然我们也可以使用github.com/deckarep/golang-set中的线程安全set,我们在下一个例子中使用. type ClientLike interface { WriteJSON(interface{}) error Close() error } type Exchange struct { clients syncmap.Map } func New() *Exchange { var sm syncmap.Map exchange := &Exchange{ clients: sm} return exchange } func (exchange *Exchange) Len() int64 { m := exchange.clients.Length() if m != nil { logger.Debug(\"length \", *m) return *m } else { logger.Error(\"length is nil\") return 0 } } func (exchange *Exchange) Sub(ws *websocket.Conn) { exchange.clients.Store(ws, true) } func (exchange *Exchange) DisSub(ws *websocket.Conn) { ok := exchange.clients.Delete(ws) if ok { logger.Debug(\"ws dissub the exchange\") } else { logger.Debug(\"ws not in exchange\") } } func (exchange *Exchange) Pub(msg string) { message := event.Event{EventType: \"message\", Message: msg} exchange.clients.Range(func(key, value interface{}) bool { client := key.(*websocket.Conn) err := client.WriteJSON(message) if err != nil { logger.Error(\"send to %v error: %v\", client, err) return false } return true }) } func (exchange *Exchange) PubNoSelf(msg string, ws *websocket.Conn) { message := event.Event{EventType: \"message\", Message: msg} exchange.clients.Range(func(key, value interface{}) bool { client := key.(*websocket.Conn) if client != ws { err := client.WriteJSON(message) if err != nil { logger.Error(\"send to %v error: %v\", client, err) return false } else { return true } } else { return true } }) } func (exchange *Exchange) Close() { exchange.clients.Range(func(key, value interface{}) bool { client := key.(*websocket.Conn) client.Close() return true }) } RoomManager 用于管理所有的room与Exchange的对应关系,使用map[string]*exchange.Exchange结构维护对应关系. type RoomManager struct { rooms syncmap.Map } func New() *RoomManager { var sm syncmap.Map room_manager := &RoomManager{ rooms: sm} return room_manager } func (rm *RoomManager) Len() int64 { return *rm.rooms.Length() } func (rm *RoomManager) Add(room_name string, exch *exchange.Exchange) { rm.rooms.Store(room_name, exch) } func (rm *RoomManager) GetRoom(room_name string) (*exchange.Exchange, error) { value, ok := rm.rooms.Load(room_name) if ok { room_exchange := value.(*exchange.Exchange) return room_exchange, nil } else { return nil, errors.RoomNotExistError } } func (rm *RoomManager) Close(room_name string) error { value, ok := rm.rooms.Load(room_name) if ok { room_exchange := value.(*exchange.Exchange) room_exchange.Close() rm.rooms.Delete(room_name) logger.Info(\"room close\", room_name) return nil } else { logger.Info(\"room not exist\", room_name) return errors.RoomNotExistError } } func (rm *RoomManager) AutoClose() { ticker := time.NewTicker(time.Second * 10) go func() { for _ = range ticker.C { rm.rooms.Range(func(key, value interface{}) bool { name := key.(string) exch := value.(*exchange.Exchange) if exch.Len() == 0 { rm.Close(name) return true } else { return false } }) } }() } var DefaultRoomManager *RoomManager = New() func Len() int64 { return DefaultRoomManager.Len() } func Add(room_name string, exch *exchange.Exchange) { DefaultRoomManager.Add(room_name, exch) } func GetRoom(room_name string) (*exchange.Exchange, error) { return DefaultRoomManager.GetRoom(room_name) } func Close(room_name string) error { return DefaultRoomManager.Close(room_name) } func AutoClose() { DefaultRoomManager.AutoClose() } 我们定义一个自动关闭的方法,每隔10s检查一次是否有room已经是空的了,如果有那么就将其关闭 这个例子中客户端通过发送类型为message,publish和publish_no_self的3个消息来验证广播功能.我们可以多开几个客户端来检查广播是否可用. 主动推送广播 在上面的例子中广播是由客户端触发发起的,这依然是请求响应模式,我们来构造一个由服务端主动推送的例子C3,它会每隔3s向房间中的客户端推送当前时间 func time_pusher() { room.ForEach(func(key, value interface{}) bool { room_exchange := value.(*exchange.Exchange) if room_exchange.Len() != 0 { room_exchange.Pub(time.Now().String()) return true } else { return false } }) } func AutoPush() { ticker := time.NewTicker(time.Second * 3) go func() { for _ = range ticker.C { time_pusher() } }() } .... func main() { ... room.AutoClose() AutoPush() server(conf.Address) } 连接管理 我们可以看到这个websocket实现的api是比较底层的,和js原版的差不太多,只有点对点的消息传输,没有连接管理,为了可以做好连接管理我们通常需要一套用户系统,这将是下一节内容的一部分. "}}